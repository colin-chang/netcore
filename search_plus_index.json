{"./":{"url":"./","title":"前言","keywords":"","body":".Net Core .NET Core 是开放源代码通用开发平台，由 Microsoft 和 .NET 社区在 GitHub 上共同维护。 它跨平台（支持 Windows、macOS 和 Linux），并且可用于生成设备、云和 IoT 应用程序。 https://docs.microsoft.com/zh-cn/dotnet/core/about .NET Core 具有以下特性： 跨平台： 可以在 Windows、macOS 和 Linux 操作系统上运行。 跨体系结构保持一致： 在多个体系结构（包括 x64、x86 和 ARM）上以相同的行为运行代码。 命令行工具： 包括用于本地开发和持续集成方案中的易于使用的命令行工具。 部署灵活： 可以包含在应用或已安装的并行用户或计算机范围中。 可搭配 Docker 容器使用。 兼容性：.NET Core 通过 .NET Standard与 .NET Framework、Xamarin 和 Mono 兼容。 开放源：.NET Core 是一个开放源平台，使用 MIT 和 Apache 2 许可证。 .NET Core 是一个 .NET * oundation 项目。 由 Microsoft 支持：.NET Core 由 Microsoft 依据 .NET Core 支持提供支持。 How to run? npm install gitbook-cli -g gitbook install gitbook serve © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:25 "},"pages/install-install.html":{"url":"pages/install-install.html","title":"1.1 安装部署","keywords":"","body":".Net Core 安装卸载 1. 安装 2. 卸载 作为新一代微软高效跨平台技术，.Net Core自诞生以来就是跨平台的，目前支持Windows/mac OS/Linux平台。 Linux发行版众多，截止到写这篇文档时，.Net Core 2.2支持的Linux发行版如下： RHEL Ubuntu 18.04 Ubuntu 16.04 Ubuntu 14.04 Debian 9 Debian 8 Fedora 28 Fedora 27 CentOS / Oracle openSUSE Leap SLES 1. 安装 .Net Core的安装异常简单。到官网下载安装即可。Windows和Mac中都是下载安装包，双击运行安装，不再赘述。Linux选择对应的发行版本，执行官方的安装命令即可。 提醒 Debian 9 安装.Net Core之前要先安装apt-transport-https（官方安装步骤遗漏了此步骤） $ sudo apt-get install apt-transport-https 如果想体验最新版的.Net Core的特性，则可以到.Net Core的Github项目中下载。这里有.Net Core所有版本，包括历史版本和预览版本。 https://github.com/dotnet/core/tree/master/release-notes .Net Core安装包分为Runtime和SDK。如果只期望在平台上运行.Net Core程序，安装Runtime包即可。如果希望在平台上使用.Net Core的高级功能，如开发调试等，则需要安装SDK包。SDK包含了Runtime。 2. 卸载 .Net Core在Windows卸载非常简单，直接在控制面板中卸载即可。至于Mac和Linux环境下卸载就比较麻烦了。由于安装文件比较分散，所以删除和清理工作也比较繁琐，幸好.NET Foundation提供了卸载脚本。 #!/usr/bin/env bash # # Copyright (c) .NET Foundation and contributors. All rights reserved. # Licensed under the MIT license. See LICENSE file in the project root for full license information. # DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\" current_userid=$(id -u) if [ $current_userid -ne 0 ]; then echo \"$(basename \"$0\") uninstallation script requires superuser privileges to run\" >&2 exit 1 fi # this is the common suffix for all the dotnet pkgs dotnet_pkg_name_suffix=\"com.microsoft.dotnet\" dotnet_install_root=\"/usr/local/share/dotnet\" dotnet_path_file=\"/etc/paths.d/dotnet\" remove_dotnet_pkgs(){ installed_pkgs=($(pkgutil --pkgs | grep $dotnet_pkg_name_suffix)) for i in \"${installed_pkgs[@]}\" do echo \"Removing dotnet component - \\\"$i\\\"\" >&2 pkgutil --force --forget \"$i\" done } remove_dotnet_pkgs [ \"$?\" -ne 0 ] && echo \"Failed to remove dotnet packages.\" >&2 && exit 1 echo \"Deleting install root - $dotnet_install_root\" >&2 rm -rf \"$dotnet_install_root\" rm -f \"$dotnet_path_file\" echo \"dotnet packages removal succeeded.\" >&2 exit 0 使用以上脚本卸载即可。 如果对shell脚本不熟悉的小伙伴也可以使用以下命令快速卸载，以mac为例， $ curl -o uninstall.sh https://gist.githubusercontent.com/colin-chang/1d8da588f399165924dc62dad42598d8/raw/50444ab4db30ab8d6205216dec0c3983333a5d6b/dotnet-uninstall-pkgs.sh && chmod -R 740 uninstall.sh && sudo sh uninstall.sh && rm uninstall.sh © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/install-deploy.html":{"url":"pages/install-deploy.html","title":"1.2 部署项目","keywords":"","body":".Net Core 部署 .Net Core 部署 1. Linux(Kestrel+Nginx) 2. Windows(Kestrel+IIS) 3. Docker .Net Core程序可以部署在Windows/Linux/mac平台上。Mac较多的用于开发，鲜少用做服务器环境。下面我们以Asp.Net Core为例，简单梳理一下。 .net core程序无论是调试还是发布版本，都建议在程序目录下运行命令，否则可能会出现静态资源文件无法访问的问题。 发布命令 dotnet publish -c Release 1. Linux(Kestrel+Nginx) 在Linux中也可以使用 dotnet ./your_app.dll 方式在终端中运行.Net Core程序，但是退出终端后，程序就停止了。我们可以将运行命令封装到一个Linux服务中，服务器启动后就可以在后台静默运行了。 systemd 可用于创建服务文件以启动和监视基础 Web 应用。 systemd 是一个 init 系统，可以提供用于启动、停止和管理进程的许多强大的功能。 创建服务文件 $ sudo vi /etc/systemd/system/lottery.service 服务文件示例 [Unit] # 服务描述 Description=Lottery [Service] # 工作目录，此处为.net core程序目录 WorkingDirectory=/home/colin/apps/content/lottery # dotnet核心命令 ExecStart=/usr/bin/dotnet /home/colin/apps/content/lottery/Lottery.WebApp.dll # 重启策略 Restart=always RestartSec=10 # 日志标识 SyslogIdentifier=dotnet-lottery # 用户 User=colin # 环境变量 Environment=ASPNETCORE_ENVIRONMENT=Production Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false [Install] WantedBy=multi-user.target 服务管理 # 启用服务 $ sudo systemctl enable lottery.service # 启动服务 $ sudo systemctl start lottery.service # 查看服务状态 $ sudo systemctl status lottery.service # 停止服务 $ sudo systemctl stop lottery.service # 重启服务 $ sudo systemctl restart lottery.service 完成以上步骤之后，Asp.Net Core程序已经挂载到了Kestrel服务器上并以Linux服务方式后台静默运行。虽然Kestrel服务器对Asp.Net支持非常好，但微软不建议其作为对外服务器，而是建议使用IIS/Nginx/Apache等作为代理服务器对外开放。 关于Linux下Nginx部署，参阅： https://ccstudio.org/linux/part2/nginx.html https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.2 Apache配置，参阅： https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-apache?view=aspnetcore-2.2 2. Windows(Kestrel+IIS) Asp.Net Core应用程序部署要求Windows系统环境为： Windows 7 或更高版本 Windows Server 2008 R2 或更高版本 整体部署于传统Asp.Net MVC部署方式相似。使用Kestrel+IIS的进程外承载模型时，需要为IIS安装AspNetCoreModule，然后将应用程序池的.NET CLR版本设置为无托管代码即可。 Windows 下.Net Core部署流程参阅： https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/?view=aspnetcore-2.2 3. Docker .Net Core可以使用Docker技术实现跨平台的容器部署。 .Net Core应用程序Docker部署参阅制作网站镜像 Nginx反代服务器Docker部署参阅https://ccstudio.org/linux/part2/nginx.html。 可以参阅lottery项目的部署过程。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/config.html":{"url":"pages/config.html","title":"2. 配置管理","keywords":"","body":"配置管理 .Net Core项目配置使用方式与.Net Framework程序不同。 .Net Core配置依赖于Microsoft.Extensions.Configuration和Microsoft.Extensions.Configuration.Json(使用Json配置文件时需要)。新版Microsoft.AspNetCore.App包中默认包含了以上两个Nuget包，所以Asp.Net Core应用管理配置不需要再额外引用相关Nuget包。 .Net Core 配置内容都是以 key-value 对形式存在的。 1. 命令行和内存配置 .Net Core程序读取命令行配置依赖于Microsoft.Extensions.Configuration.CommandLineNuget包(Asp.Net Core默认已安装)。 我们可以通过以下语法读取命令行和内存配置数据。 static void Main(string[] args) { var settings = new Dictionary { {\"name\", \"Colin\"}, {\"age\", \"18\"} }; var config = new ConfigurationBuilder() //实例化配置对象工厂 .AddInMemoryCollection(settings) //使用内存集合配置 .AddCommandLine(args) //使用命令行配置 .Build(); //获取配置根对象 //获取配置 Console.WriteLine($\"name:{config[\"name\"]} \\t age:{config[\"age\"]}\"); } 运行以上程序。 $ dotnet run cmddemo # 输出 name:Colin age:18 $ dotnet run cmddemo name=Robin age=20 # 输出 name:Robin age:20 $ dotnet run cmddemo --name Robin --age 20 # 输出 name:Robin age:20 由于AddCommandLine()在AddInMemoryCollection()之后，所以当命令行有参数时会覆盖内存配置信息。 2. Json文件配置 相比与命令行和内存配置，我们更常用Json文件来存储配置信息。这Json文件内容没有任何要求，只要符合Json格式即可。 假定项目目录下有名为appsettings.json的配置文件，内容如下： { \"AppName\": \"配置测试\", \"Class\": { \"ClassName\": \"三年二班\", \"Master\": { \"Name\": \"Colin\", \"Age\": 25 }, \"Students\": [ { \"Name\": \"Robin\", \"Age\": 20 }, { \"Name\": \"Sean\", \"Age\": 23 } ] } } static void Main(string[] args) { var config = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\") .Build(); Console.WriteLine($\"AppName:{config[\"AppName\"]}\"); Console.WriteLine($\"ClassName:{config[\"Class:ClassName\"]}\"); Console.WriteLine($\"Master:\\r\\nName:{config[\"Class:Master:Name\"]}\\tAge:{config[\"Class:Master:Age\"]}\"); Console.WriteLine(\"Students:\"); Console.WriteLine($\"Name:{config[\"Class:Students:0:Name\"]}\\tAge:{config[\"Class:Students:0:Age\"]}\"); Console.WriteLine($\"Name:{config[\"Class:Students:1:Name\"]}\\tAge:{config[\"Class:Students:1:Age\"]}\"); } 除了可以使用IConfiguration类型的索引器方式读取配置，还可以通过其GetSection(string key)方法读取配置。GetSection()方法返回类型为IConfigurationSection，可以链式编程方式读取多层配置。 var clsName = config.GetSection(\"Class\").GetSection(\"ClassName\").Value; //clsName=\"三年二班\" 3. 配置对象映射 前面提到的配置读取方式只能读取到配置项的字符串格式\b的内容，遇到较为复杂的配置我们更期望配置信息可以映射为C#当中的一个对象。 我们为前面使用的配置文件定义实体类内容如下: public class Class { public string ClassName { get; set; } public Master Master { get; set; } public IEnumerable Students { get; set; } } public abstract class Person { public string Name { get; set; } public int Age { get; set; } } public class Master : Person{} public class Student : Person{} 3.1 Bind Microsoft.Extensions.Configuration.Binder\b为IConfiguration扩展了三个Bind()方法，其作用是尝试将给定的配置信息映射为一个对象。 1) .Net Core var cls = new Class(); config.Bind(\"Class\",cls); // 执行完成后配置文件内容将映射到cls对象中 2) Asp.Net Core Asp.Net Core中默认包含了需要的Nuget包，在Startup.cs中直接使用Configuration.Bind()即可获得配置映射的Class对象，如需在其他位置使用此配置对象，需要手动将其注册到服务列表中。 public void ConfigureServices(IServiceCollection services) { // other services ... var cls = new Class(); Configuration.Bind(\"Class\",cls); services.AddSingleton(cls); //服务注册 } 3.2 Config Microsoft.Extensions.Options.ConfigurationExtensions包为IServiceCollection扩展了Configure方法，其作用是注册一个配置对象并绑定为IOptions对象。该种方式配合DI使用，DI的详细介绍参阅依赖注入。 1) .Net Core 普通.Net Core项目使用DI需要引入Microsoft.Extensions.DependencyInjection Nuget包。 //注册服务 var serviceCollection = new ServiceCollection(); serviceCollection.Configure(config.GetSection(\"Class\")); //消费服务 var cls = serviceCollection.BuildServiceProvider().GetService>().Value; 2) Asp.Net Core 在Asp.Net Core中配置使用十分简便，在Startup.cs中作如下配置： public void ConfigureServices(IServiceCollection services) { // other services ... services.Configure(Configuration.GetSection(\"Class\")); //注册配置服务 } 在控制器等位置消费服务与普通IOptions服务一样。 private readonly Class _cls; public HomeController(IOptions classAccesser) { _cls = classAccesser.Value; } 4. 配置文件热更新 .Net Core中配置文件是支持热更新的。在ConfigurationBuilder的AddJsonFile()方法中reloadOnChange参数表示配置文件变更后是否自动重新加载(热更新)。 new ConfigurationBuilder().AddJsonFile(\"appsettings.json\", true, true) 3.1 Bind方式配置文件读取方式并不支持热更新。Config方式支持配置文件热更新但是需要使用 IOptionsSnapshot 替换 IOptions。 private readonly Class _cls; public HomeController(IOptionsSnapshot classAccesser) { _cls = classAccesser.Value; } 在Asp.Net Core中不指定配置文件时默认使用应用根目录下的appsettings.json文件作为配置文件并且启用了热更新，这在WebHost.CreateDefaultBuilder(args)过程中完成，若要使用自定义配置文件名称可以通过以下方式修改。 WebHost.CreateDefaultBuilder(args) .ConfigureAppConfiguration(config => config.AddJsonFile(\"myconfig.json\",true,false)) 开启配置文件热更新后程序会启动一个后台线程监听配置文件是否变动，如果配置文件不需要经常改动可以关闭配置文件热更新以减少系统开支，关闭方式同上。 5. 配置管理工具类封装 在Asp.Net Core程序中我们可以方便的通过以上Config方式使用配置，但在其它.Net Core应用中DI并未默认被引入，我们可以考虑配置文件读取操作封装为一个工具类。考虑到配置文件热更新问题对象映射我们采用Config方式处理。 代码已上传到Github，这里不再展开。 https://github.com/colin-chang/ConfigurationManager.Core 具体使用方式可以查看示例项目。 https://github.com/colin-chang/ConfigurationManager.Core/tree/master/ColinChang.ConfigurationManager.Sample 该帮助类已发布到Nuget # Package Manager Install-Package ColinChang.ConfigurationManager.Core # .NET CLI dotnet add package ColinChang.ConfigurationManager.Core 6. Configuration框架解析 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-intro.html":{"url":"pages/di-intro.html","title":"3.1 依赖注入引入","keywords":"","body":"Asp.Net Core 无处不在的“依赖注入” ASP.NET Core的核心是通过一个Server和若干注册的Middleware构成的管道，不论是管道自身的构建，还是Server和Middleware自身的实现，以及构建在这个管道的应用，都需要相应的服务提供支持，ASP.NET Core自身提供了一个DI容器来实现针对服务的注册和消费。换句话说，不只是ASP.NET Core底层框架使用的服务是由这个DI容器来注册和提供，应用级别的服务注册和提供也需要依赖这个DI容器。学习ASP.NET Core，你必须了解无处不在的“依赖注入”。 说到依赖注入（Dependency Injection，以下简称DI），就必须说IoC（Inverse of Control），很多人将这两这混为一谈，其实这是两个完全不同的概念，或者是不同“层次”的两个概念。在本系列后续控制反转（IoC）和依赖注入（DI）中有详细讲解。 DI框架具有两个核心的功能，即服务的注册和提供，这两个功能分别由对应的对象来承载, 它们分别是ServiceCollection和ServiceProvider。如下图所示，我们将相应的服务以不同的生命周期模式（Transient、Scoped和Singleton）注册到ServiceCollection对象之上，在利用后者创建的ServiceProvider根据注册的服务类型提取相应的服务对象。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-ioc.html":{"url":"pages/di-ioc.html","title":"3.2 控制反转（IoC）","keywords":"","body":"控制反转（IoC） 1. 流程控制反转 2. 好莱坞法则 3. 流程定制 IoC主要体现了这样一种设计思想：通过将一组通用流程的控制从应用转移到框架之中以实现对流程的复用，同时采用“好莱坞原则”是应用程序以被动的方式实现对流程的定制。我们可以采用若干设计模式以不同的方式实现IoC。 1. 流程控制反转 很多人将IoC说成是一种“面向对象的设计模式”，但在我个人看来IoC不能算作一种“设计模式”，其自身也与“面向对象”没有直接的关系。很多人之所以不能很准确地理解IoC源于他们忽略了一个最根本的东西，那就是IoC这个短语。换句话说，很多人之所以对IoC产生了诸多误解是因为他们忽略了IoC的定义。 IoC的全名Inverse of Control，翻译成中文就是“控制反转”或者“控制倒置”。控制反转也好，控制倒置也罢，它体现的意思是控制权的转移，即原来控制权在A手中，现在需要B来接管。那么具体对于软件设计来说，IoC所谓的控制权的转移具有怎样的体现呢？要回答这个问题，就需要先了解IoC的C（Control）究竟指的是怎样一种控制。对于我们所在的任何一件事，不论其大小，其实可以分解成相应的步骤，所以任何一件事都有其固有的流程，IoC涉及的所谓控制可以理解为“针对流程的控制”。 我们通过一个具体事例来说明传统的设计在采用了IoC之后针对流程的控制是如何实现反转的。比如说现在设计一个针对Web的MVC类库，我们不妨将其命名为MvcLib。简单起见，这个类库中只包含如下这个同名的静态类。 public static class MvcLib { public static Task ListenAsync(Uri address); public static Task ReceiveAsync(); public static Task CreateControllerAsync(Request request); public static Task ExecuteControllerAsync(Controller controller); public static Task RenderViewAsync(View view); } MvcLib提供了如上5个方法帮助我们完成整个HTTP请求流程中的5个核心任务。具体来说，ListenAsync方法启动一个监听器并将其绑定到指定的地址进行HTTP请求的监听，抵达的请求通过ReceiveAsync方法进行接收，我们将接收到的请求通过一个Request对象来表示。CreateControllerAsync方法根据接收到的请求解析并激活请求的目标Controller对象。ExecuteControllerAsync方法执行激活的Controller并返回一个表示视图的View对象。RenderViewAsync最终将View对象转换成HTML并作为当前请求响应的内容返回给请求的客户端。 现在我们在这个MvcLib的基础上创建一个真正的MVC应用，那么除了按照MvcLib的规范自定义具体的Controller和View之外，我们还需要自行控制从请求的监听与接收、Controller的激活与执行以及View的最终呈现在内的整个流程，这样一个执行流程反映在如下所示的代码中。 class Program { static async Task Main() { Uri address = new Uri(\"http://0.0.0.0:8080/mvcapp\"); await MvcLib.ListenAsync(address); while (true) { var request = await MvcLib.ReceiveAsync(); var controller = await MvcLib.CreateControllerAsync(request); var view = await MvcLib.ExecuteControllerAsync(controller); await MvcLib.RenderViewAsync(view); } } } 这个例子体现了如图1所示的流程控制方式（应用的代码完全采用异步的方式来处理请求，为了让流程图显得更加简单，我们在流程图中画成了同步的形式，读者不必纠结这个问题）。我们设计的类库（MvcLib）仅仅通过API的形式提供某种单一功能的实现，作为类库消费者的应用程序（App）则需要自行编排整个工作流程。如果从重用的角度来讲，这里被重用的仅限于实现某个环节单一功能的代码，编排整个工作流程的代码并没有得到重用。 但是当我们构建一个应用的时候，我们需要的不仅仅是一个能够提供单一API的类库，我们希望的理想形式是能够直接在一个现有的框架上构建我们的应用。类库（Library）和框架（Framework）的不同之处在于，前者往往只是提供实现某种单一功能的API，而后者则针对一个目标任务对这些单一功能进行编排形成一个完整的流程，这个流程在一个引擎的驱动下自动执行。 对于我们上面演示MvcLib来说，作为消费者的应用程序需要自行控制整个HTTP请求的处理流程，但这实际上是一个很“泛化”的工作流程，几乎所有的MVC应用均采用这样的流程监听、接收请求并最终对请求予以响应。如果我们将这个流程实现在一个MVC框架之中，由它构建的所有MVC应用就可以直接使用这个请求处理流程，而不需要自行重复实现它。 现在我们将MvcLib从类库改造成一个框架，并姑且将其称为MvcFrame。如图2所示，MvcFrame的核心是一个被称为MvcEngine的执行引擎，它驱动一个编排好的工作流对HTTP请求进行一致性处理。如果我们利用MvcFrame构建一个具体的MVC应用，除了根据我们的业务需求定义相应的Controller和View之外，我们只需要初始化这个引擎并直接启动它即可。如果你曾经开发过ASP.NET MVC应用，你会发现ASP.NET MVC就是这么一个框架。 有了上面演示的这个例子作为铺垫，我们应该很容易理解IoC所谓的控制反转。总的来说，IoC是我们设计框架所采用的一种基本思想，所谓的控制反转就是将对应用流程的控制转移到框架中。拿上面这个例子来说，在传统面向类库编程的时代，针对HTTP请求处理的流程牢牢控制在应用程序手中。在引入框架之后，请求处理的控制权转移到了框架手上。 2. 好莱坞法则 在好莱坞，把简历递交给演艺公司后就只有回家等待。由演艺公司对整个娱乐项目的完全控制，演员只能被动式的接受电影公司的工作，在需要的环节中，完成自己的演出。“不要给我们打电话，我们会给你打电话(don‘t call us, we‘ll call you)”这是著名的好莱坞法则（ Hollywood Principle或者 Hollywood Low），IoC完美地体现了这一法则。 在IoC的应用语境中，框架就像是掌握整个电影制片流程的电影公司，由于它是整个工作流程的实际控制者，所以只有它知道哪个环节需要哪些组件。应用程序就像是演员，它只需要按照框架定制的规则注册这些组件就可以了，因为框架会在适当的时机加载并执行注册的组件。 以熟悉的ASP.NET Core MVC或者ASP.NET MVC应用开发来说，我们只需要按照约定规则（比如目录结构和命名等）定义相应的Controller类型和View文件就可以了。当ASP.NET （Core ）MVC框架在进行处理请求的过程中，它会根据解析生成的路由参数定义为对应的Controller类型，并按照预定义的规则找到我们定义的Controller，然后自动创建并执行它。如果定义在当前Action方法需要呈现一个View，框架自身会根据预定义的目录约定找到我们定义的View文件，并对它实施动态编译和执行。整个流程处处体现了“框架Call应用”的好莱坞法则。 总的来说，我们在一个框架的基础上进行应用开发，就相当于在一条调试好的流水线上生成某种商品，我们只需要在相应的环节准备对应的原材料，最终下线的就是我们希望得到的最终产品。IoC几乎是所有框架均具有的一个固有属性，从这个意义上讲，“IoC框架”的说法其实是错误的，世界上并没有什么IoC框架，或者说几乎所有的框架都是IoC框架。 3. 流程定制 我们采用IoC实现了流程控制从应用程序向框架自身的反转，但是这个被反转的仅仅是一个泛化的流程，任何一个具体的应用都可能需要对组成该流程的某些环节进行定制。还是以我们的MVC框架来说，可能默认的请求处理流程只考虑到针对HTTP 1.1的支持，但是当我们在设计框架的时候应该提供相应的扩展点来支持HTTP 2。作为一个Web框架，用户认证功能是必备的，但是框架自身不能限制于某一种或者几种固定的认证方式，应该通过扩展的方式让用户可以自由地定制任意的认证模式。 我们可以说得更加宽泛点。如下图所示，我们将一个泛化的工作流程（A=>B=>C）定义在框架之中，建立在该框架的两个应用需要对组成这个流程的某些环节进行定制。比如步骤A和C可以被App1重用，但是步骤B却需要被定制（B1），App2则重用步骤A和B，但是需要按照自己的方式处理步骤C。 IoC将对流程的控制从应用程序转移到框架之中，框架利用一个引擎驱动整个流程的执行，应用程序无需关心该工作流程的细节，它只需要启动这个引擎即可。但是这个引擎一旦被启动，框架就会完全按照预先编排好的流程进行工作，如果应用程序希望整个流程按照自己希望的方式被执行，针对流程的定制一般发生在启动引擎之前。 一般来说，框架会以相应的形式提供一系列的扩展点，应用程序则通过定义扩展的方式实现对流程某个环节的定制。在引擎被启动之前，应用程序将所需的扩展注册到框架之中。一旦引擎被正常启动，这些注册的扩展会自动参与到整个流程的执行过程中。 综上所述，IoC一方面通过流程控制从应用程序向框架的反转实现了针对流程自身的重用，另一方面通过内置的扩展机制这个被重用的流程可能自由地被定制，这两个因素决定了框架自身的价值。重用让框架不仅仅是为应用程序提供实现单一功能的API，而是提供一整套可执行的解决方案，可定制则使我们可以为不同的应用程序对框架进行定制，这无疑让框架可以使用到更多的应用之中。 参考文献 https://www.cnblogs.com/artech/p/net-core-di-01.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-designmode.html":{"url":"pages/di-designmode.html","title":"3.3 基于IoC的设计模式","keywords":"","body":"基于IoC的设计模式 1. 模板方法（Template Method） 2. 工厂方法（Factory Method） 3. 抽象工厂（Abstract Factory） 正如我们在前面提到过的，很多人将IoC理解为一种“面向对象的设计模式”，实际上IoC自身不仅与面向对象没有必然的联系，它也算不上是一种设计模式。一般来讲，设计模式提供了一种解决某种具体问题的方案，但是IoC既没有一个针对性的问题领域，其自身没有提供一种可实施的解决方案，所以我更加倾向于将IoC视为一种设计原则，实际上很多我们熟悉的设计模式背后采用了IoC原则。 1. 模板方法（Template Method） 提到IoC，很多人首先想到的是DI，但是在我看来与IoC思想最为接近的倒是另一种被称为“模板方法（Template Method）”的设计模式。模板方法模式与IoC的意图可以说不谋而合，该模式主张将一个可复用的工作流程或者由多个步骤组成的算法定义成模板方法，组成这个流程或者算法的步骤实现在相应的虚方法之中，模板方法根据预先编排的流程去调用这些虚方法。所有这些方法均定义在同一个类中，我们可以通过派生该类并重写相应的虚方法达到对流程定制的目的。 对于控制反转（IoC）演示的这个MVC的例子，我们可以将整个请求处理流程实现在如下一个MvcEngine类中，请求的监听与接收、目标Controller的激活与执行以及View的呈现分别定义在5个受保护的虚方法中，模板方法StartAsync根据预定义的请求处理流程先后调用这5个方法。 public class MvcEngine { public async Task StartAsync(Uri address) { await ListenAsync(address); while (true) { var request = await ReceiveAsync(); var controller = await CreateControllerAsync(request); var view = await ExecuteControllerAsync(controller); await RenderViewAsync(view); } } protected virtual Task ListenAsync(Uri address); protected virtual Task ReceiveAsync(); protected virtual Task CreateControllerAsync(Request request); protected virtual Task ExecuteControllerAsync(Controller controller); protected virtual Task RenderViewAsync(View view); } 对于具体的应用来说，如果MvcEngine中针对请求的处理方式完全符合要求，则它只需要创建一个MvcEngine对象，然后指定一个对应的基地址调用模板方法StartAsync开启这个MVC引擎即可。如果该MVC引擎处理请求的某个环节不能满足它的要求，它可以创建MvcEngine的派生类，并重写实现该环节的相应虚方法即可。 比如说定义在某个应用程序中的Controller都是无状态的，它希望采用单例（Singleton）的方式重用已经激活的Controller以提高性能，那么它就可以按照如下的方式创建一个自定义的FoobarMvcEngine并按照自己的方式重写 public class FoobarMvcEngine : MvcEngine { protected override Task CreateControllerAsync (Request request) { // > } } 2. 工厂方法（Factory Method） 对于一个复杂的流程来说，我们倾向于将组成该流程的各个环节实现在相对独立的组件之中，那么针对流程的定制就可以通过提供定制组件的方式来实现。我们知道23种设计模式之中有一种重要的类型，那就是“创建型模式”，比如常用的“工厂方法”和“抽象工厂”，IoC所体现的针对流程的共享与定制可以通过它们来完成。 所谓的工厂方法，说白了就是在某个类中定义用于提供依赖对象的方法，这个方法可以是一个单纯的虚方法，也可以是具有默认实现的虚方法，至于方法声明的返回类型，可以是一个接口或者抽象类，也可以是未被封闭（Sealed）的具体类型。作为它的派生类型，它可以实现或者重写工厂方法以提供所需的具体对象。 同样以我们的MVC框架为例，我们让独立的组件来完成组成整个请求处理流程的几个核心环节。具体来说，我们针对这些核心组件定义了如下这几个对应的接口。IWebLister接口用来监听、接收和响应请求（针对请求的响应由ReceiveAsync方法返回的HttpContext对象来完成，后者表示针对当前请求的上下文），IControllerActivator接口用于根据当前请求激活目标Controller对象，已经在后者执行完成后做一些释放回收工作。至于IControllerExecutor和IViewRender接口则分别用来完成针对Controller的执行和针对View的呈现。 public interface IWebLister { Task ListenAsync(Uri address); Task ReceiveAsync(); } public interface IControllerActivator { Task CreateControllerAsync(HttpContext httpContext); Task ReleaseAsync(Controller controller); } public interface IControllerExecutor { Task ExecuteAsync(Controller controller, HttpContext httpContext); } public interface IViewRender { Task RendAsync(View view, HttpContext httpContext); } 我们在作为MVC引擎的MvcEngine类中定义了四个工厂方法（GetWebListener、GetControllerActivator、GetControllerExecutor和GetViewRenderer）来提供上述这4种组件。这四个工厂方法均为具有默认实现的虚方法，我们可以利用它们提供默认的组件。在用于启动引擎的StartAsync方法中，我们利用这些工厂方法提供的对象来具体完成请求处理流程的各个核心环节。 public class MvcEngine { public async Task StartAsync(Uri address) { var listener = GetWebLister(); var activator = GetControllerActivator(); var executor = GetControllerExecutor(); var render = GetViewRender(); await listener.ListenAsync(address); while (true) { var httpContext = await listener.ReceiveAsync(); var controller = await activator.CreateControllerAsync(httpContext); try { var view = await executor.ExecuteAsync(controller, httpContext); await render.RendAsync(view, httpContext); } finally { await activator.ReleaseAsync(controller); } } } protected virtual IWebLister GetWebLister(); protected virtual IControllerActivator GetControllerActivator(); protected virtual IControllerExecutor GetControllerExecutor(); protected virtual IViewRender GetViewRender(); } 对于具体的应用程序来说，如需对请求处理某个环节进行定制，在对应接口实现类中重写对应的工厂方法即可。比如上面提及的以单例模式提供目标Controller对象的实现就定义在SingletonControllerActivator类中，我们在派生于MvcEngine的FoobarMvcEngine类中重写了工厂方法GetControllerActivator使其返回一个SingletonControllerActivator对象。 public class SingletonControllerActivator : IControllerActivator { public Task CreateControllerAsync(HttpContext httpContext) { // > } public Task ReleaseAsync(Controller controller) => Task.CompletedTask; } public class FoobarMvcEngine : MvcEngine { protected override ControllerActivator GetControllerActivator() => new SingletonControllerActivator(); } 3. 抽象工厂（Abstract Factory） 虽然工厂方法和抽象工厂均提供了一个“生产”对象实例的工厂，但是两者在设计上却有本质的不同。工厂方法利用定义在某个类型的抽象方法或者虚方法实现了针对单一对象提供方式的抽象，而抽象工厂则利用一个独立的接口或者抽象类来提供一组相关的对象。 具体来说，我们需要定义一个独立的工厂接口或者抽象工厂类，并在其中定义多个的工厂方法来提供“同一系列”的多个相关对象。如果希望抽象工厂具有一组默认的“产出”，我们也可以将一个未被封闭的具体类作为抽象工厂，以虚方法形式定义的工厂方法将默认的对象作为返回值。我们根据实际的需要通过实现工厂接口或者继承抽象工厂类（不一定是抽象类）定义具体工厂类来提供一组定制的系列对象。 现在我们采用抽象工厂模式来改造我们的MVC框架。如下面的代码片段所示，我们定义了一个名为IMvcEngineFactory的接口作为抽象工厂，其中定义了四个方法来提供请求监听和处理过程使用到的4种核心对象。如果MVC提供了针对这四种核心组件的默认实现，我们可以按照如下的方式为这个抽象工厂提供一个默认实现（MvcEngineFactory）。 public interface IMvcEngineFactory { IWebLister GetWebLister(); IControllerActivator GetControllerActivator(); IControllerExecutor GetControllerExecutor(); IViewRender GetViewRender(); } public class MvcEngineFactory： IMvcEngineFactory { IWebLister GetWebLister(); IControllerActivator GetControllerActivator(); IControllerExecutor GetControllerExecutor(); IViewRender GetViewRender(); } 现在我们采用抽象工厂模式来改造我们的MVC框架。在创建MvcEngine对象时可以提供一个具体的IMvcEngineFactory对象，如果没有显式指定，MvcEngine会使用默认的EngineFactory对象。在用于启动引擎的StartAsync方法中，MvcEngine利用IMvcEngineFactory来获取相应的对象协作完成对请求的处理流程。 public class MvcEngine { public IMvcEngineFactory EngineFactory { get; } public MvcEngine(IMvcEngineFactory engineFactory = null) => EngineFactory = engineFactory??new MvcEngineFactory(); public async Task StartAsync(Uri address) { var listener = EngineFactory.GetWebLister(); var activator = EngineFactory.GetControllerActivator(); var executor = EngineFactory.GetControllerExecutor(); var render = EngineFactory.GetViewRender(); await listener.ListenAsync(address); while (true) { var httpContext = await listener.ReceiveAsync(); var controller = await activator.CreateControllerAsync(httpContext); try { var view = await executor.ExecuteAsync(controller, httpContext); await render.RendAsync(view, httpContext); } finally { await activator.ReleaseAsync(controller); } } } } 如果具体的应用程序需要采用上面定义的SingletonControllerActivator以单例的模式来激活目标Controller，我们可以按照如下的方式定义一个具体的工厂类FoobarEngineFactory。最终的应用程序将这么一个FoobarEngineFactory对象作为MvcEngine的EngineFactory。 public class FoobarEngineFactory : EngineFactory { public override ControllerActivator GetControllerActivator() { return new SingletonControllerActivator(); } } public class App { static void Main(string[] args) { Uri address = new Uri(\"http://0.0.0.0:8080/mvcapp\"); MvcEngine engine = new MvcEngine(new FoobarEngineFactory()); engine.Start(address); } } 除了上面介绍这三种典型的设计，还有很多其他的设计模式，比如策略模式、观察者模式等等，它们无一不是采用IoC的设计原则。 参考文献 https://www.cnblogs.com/artech/p/net-core-di-02.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-di.html":{"url":"pages/di-di.html","title":"3.4 依赖注入（DI）","keywords":"","body":"依赖注入（DI） 1. 容器提供服务 2. 依赖注入方式 2.1 构造器注入 2.2 属性注入 2.3 方法注入 3. Service Locator 4. .Net Core中的DI 1. 容器提供服务 和基于IoC的设计模式中介绍的工厂方法和抽象工厂模式一样，DI是一种“对象提供型”的设计模式，在这里我们将提供的对象统称为“服务”、“服务对象”或者“服务实例”。在一个采用DI的应用中，在定义某个服务类型的时候，我们直接将依赖的服务采用相应的方式注入进来。按照“面向接口编程”的原则，被注入的最好是依赖服务的接口而非实现。 在应用启动的时候，我们会对所需的服务进行全局注册。服务一般都是针对接口进行注册的，服务注册信息的核心目的是为了在后续消费过程中能够根据接口创建或者提供对应的服务实例。按照“好莱坞法则”，应用只需要定义好所需的服务，服务实例的激活和调用则完全交给框架来完成，而框架则会采用一个独立的“容器（Container）”来提供每一个服务实例。 框架用来提供服务的容器称为“DI容器”，也有很多人将其称为“IoC容器”，根据我们在《控制反转》针对IoC的介绍，我不认为后者是一个合理的称谓。DI容器之所以能够按照我们希望的方式来提供所需的服务是因为该容器是根据服务注册信息来创建的，服务注册了包含提供所需服务实例的所有信息。 举个简单的例子，我们创建一个名为Cat的DI容器类，那么我们可以通过调用具有如下定义的扩展方法GetService从某个Cat对象获取指定类型的服务对象。我之所以将其命名为Cat，源于我们大家都非常熟悉的一个卡通形象“机器猫（哆啦A梦）”。机器猫的那个四次元口袋就是一个理想的DI容器，大熊只需要告诉哆啦A梦相应的需求，它就能从这个口袋中得到相应的法宝。DI容器亦是如此，服务消费者只需要告诉容器所需服务的类型（一般是一个服务接口或者抽象服务类），就能得到与之匹配的服务实例 public static class CatExtensions { public static T GetService(this Cat cat); } 对于演示的MVC框架，我们在基于IoC的设计模式中分别采用不同的设计模式对框架的核心类型MvcEngine进行了改造，现在我们采用DI的方式并利用上述的这个Cat容器按照如下的方式对其进行重新实现，我们会发现MvcEngine变得异常简洁而清晰。 public class MvcEngine { public Cat Cat { get; } public MvcEngine(Cat cat) => Cat = cat; public async Task StartAsync(Uri address) { var listener = Cat.GetService(); var activator = Cat.GetService(); var executor = Cat.GetService(); var render = Cat.GetService(); await listener.ListenAsync(address); while (true) { var httpContext = await listener.ReceiveAsync(); var controller = await activator.CreateControllerAsync(httpContext); try { var view = await executor.ExecuteAsync(controller, httpContext); await render.RendAsync(view, httpContext); } finally { await activator.ReleaseAsync(controller); } } } } 从服务消费的角度来讲，我们借助于一个服务接口对消费的服务进行抽象，那么服务消费程序针对具体服务类型的依赖可以转移到对服务接口的依赖上，但是在运行时提供给消费者的总是一个针对某个具体服务类型的对象。不仅如此，要完成定义在服务接口的操作，这个对象可能需要其他相关对象的参与，也就是说提供的这个服务对象可能具有针对其他对象的依赖。作为服务对象提供者的DI容器，在它向消费者提供服务对象之前就会根据服务实现类型和服务注册信息自动创建依赖的服务实例，并将后者注入到当前对象之中。 2. 依赖注入方式 从服务使用的角度来讲，我们借助于一个接口对服务进行抽象，那么依赖将转移到服务接口上。在运行时提供给消费者的则是具体服务类型的对象。 在具体服务类型中要实现服务接口定义的成员时，可能需要第三方对象辅助，这就产生了对第三方对象的依赖。DI容器在提供服务对象之前会自动注入这些第三方依赖到当前对象中。 服务消费程序调用GetService()方法向DI容器索取一个实现了IFoo接口的某个类型的对象，DI容器会根据预先注册的类型匹配关系创建一个类型为Foo的对象。此外，Foo对象依赖Bar和Baz对象的参与才能实现定义在服务接口IFoo之中的操作，所以Foo具有了针对Bar和Baz的直接依赖。至于Baz，它又依赖Qux，那么后者成为了Foo的间接依赖。对于DI容器最终提供的Foo对象，它所直接或者间接依赖的对象Bar、Baz和Qux都会预先被初始化并自动注入到该对象之中。 从编程的角度来讲，类型中的属性是依赖的一种主要体现形式，如果类型A中具有一个B类型的属性，那么A就对B产生了依赖。所谓依赖注入，我们可以简单地理解为一种针对依赖属性的自动初始化方式。具体来说，我们可以通过三种主要的方式达到这个目的，这就是接下来着重介绍的三种依赖注入方式。 2.1 构造器注入 构造器注入就在在构造函数中借助参数将依赖的对象注入到创建的对象之中。如下面的代码片段所示，Foo针对Bar的依赖体现在只读属性Bar上，针对该属性的初始化实现在构造函数中，具体的属性值由构造函数的传入的参数提供。当DI容器通过调用构造函数创建一个Foo对象之前，需要根据当前注册的类型匹配关系以及其他相关的注入信息创建并初始化参数对象。 public class Foo { public IBar Bar{get;} public Foo(IBar bar) =>Bar = bar; } 除此之外，构造器注入还体现在对构造函数的选择上面。如下面的代码片段所示，Foo类上面定义了两个构造函数，DI容器在创建Foo对象之前首先需要选择一个适合的构造函数。至于目标构造函数如何选择，不同的DI容器可能有不同的策略，比如可以选择参数最多或者最少的，或者可以按照如下所示的方式在目标构造函数上标注一个InjectionAttribute特性。 public class Foo { public IBar Bar{get;} public IBaz Baz {get;} [Injection] public Foo(IBar bar) =>Bar = bar; public Foo(IBar bar, IBaz):this(bar) =>Baz = baz; } 2.2 属性注入 如果依赖直接体现为类的某个属性，并且该属性不是只读的，我们可以让DI容器在对象创建之后自动对其进行赋值进而达到依赖自动注入的目的。一般来说，我们在定义这种类型的时候，需要显式将这样的属性标识为需要自动注入的依赖属性以区别于该类型的其他普通的属性。如下面的代码片段所示，Foo类中定义了两个可读写的公共属性Bar和Baz，我们通过标注InjectionAttribute特性的方式将属性Baz设置为自动注入的依赖属性。对于由DI容器提供的Foo对象，它的Baz属性将会自动被初始化。 public class Foo { public IBar Bar{get; set;} [Injection] public IBaz Baz {get; set;} } 2.3 方法注入 体现依赖关系的属性可以通过方法的形式初始化。如下面的代码片段所示，Foo针对Bar的依赖体现在只读属性上，针对该属性的初始化实现在Initialize方法中，具体的属性值由构造函数的传入参数提供。我们同样通过标注特性（InjectionAttribute）的方式将该方法标识为注入方法。DI容器在调用构造函数创建一个Foo对象之后，它会自动调用这个Initialize方法对只读属性Bar进行赋值。在调用该方法之前，DI容器会根据预先注册的类型映射和其他相关的注入信息初始化该方法的参数。 public class Foo { public IBar Bar{get;} [Injection] public void Initialize(IBar bar)=> Bar = bar; } 除了上述这种通过DI容器在初始化服务过程中自动调用的实现在外，我们还可以利用它实现另一个更加自由的方法注入形式，后者在ASP.NET Core应用具有广泛的应用。ASP.NET Core在启动的时候会调用我们注册的Startup对象来完成中间件的注册，当我们在定义这个Startup类型的时候不需要让它实现某个接口，所以用于注册中间件的Configure方法其实没有一个固定的声明，我们可以按照如下的方式将任意依赖的服务直接注入到这个方法中。 public class Startup { public void Configure(IApplicationBuilder app, IFoo foo, IBar bar, IBaz baz); } 类似的注入方式同样可以应用到中间件的定义中。与用于注册中间件的Startup类型一样，ASP.NET Core框架下的中间件类型同样不需要实现某个预定义的接口，用于处理请求的InvokeAsync或者Invoke方法上可以按照如下的方式注入任意的依赖服务。 public class FoobarMiddleware { private readonly RequestDelegate _next; public FoobarMiddleware(RequestDelegate next) =>_next = next; public Task InvokeAsync(HttpContext httpContext, IFoo foo, IBar bar, IBaz baz); } 上面这种方式的方法注入促成了一种“面向约定”的编程方式，由于不再需要实现某个预定义的接口或者继承某一个预定义的类型，需要实现的方法的声明也就少了对应的限制，这样就可用采用最直接的方式将依赖的服务注入到所需的方法中。 对于上面介绍的这几种注入方式，构造器注入是最为理想的形式，我个人不建议使用属性注入和方法注入（上面介绍这种基于约定的方法注入除外）。我们定义的服务类型应该是独立自治的，我们不应该对它运行的环境做过多的假设和限制，也就是说同一个服务类型可以使用在框架A中，也可以实现在框架B上；在没有使用任何DI容器的应用中可以使用这个服务类型，当任何一种DI容器被使用到应用中之后，该服务类型依旧能够被正常使用。对于上面介绍的这三种注入方式，只有构造器注入能够达到这个目的，而属性注入和方法注入都依赖于某个具体的DI框架来实现针对依赖属性的自动赋值和依赖方法的自动调用。 3. Service Locator 假设我们需要定义一个服务类型Foo，它依赖于另外两个服务Bar和Baz，后者对应的服务接口分别为IBar和IBaz。如果当前应用中具有一个DI容器（假设类似于我们在上面定义的Cat），那么我们可以采用如下两种方式来定义这个服务类型Foo。 public class Foo : IFoo { public IBar Bar { get; } public IBaz Baz { get; } public Foo(IBar bar, IBaz baz) { Bar = bar; Baz = baz; } public async Task InvokeAsync() { await Bar.InvokeAsync(); await Baz.InvokeAsync(); } } public class Foo : IFoo { public Cat Cat { get; } public Foo(Cat cat) => Cat = cat; public async Task InvokeAsync() { await Cat.GetService().InvokeAsync(); await Cat.GetService().InvokeAsync(); } } 从表面上看，上面提供的这两种服务类型的定义方式貌似都不错，至少它们都解决针对依赖服务的耦合问题，将针对服务实现的依赖转变成针对接口的依赖。那么哪一种更好呢？我想有人会选择第二种定义方式，因为这种定义方式不仅仅代码量更少，针对服务的提供也更加直接。我们直接在构造函数中“注入”了代表“DI容器”的Cat对象，在任何使用到依赖服务的地方，我们只需要利用它来提供对应的服务实例就可以了。 但事实上第二种定义方式采用的设计模式根本就不是“依赖注入”，而是一种被称为“Service Locator”的设计模式。Service Locator模式同样具有一个通过服务注册创建的全局的容器来提供所需的服务实例，该容器被称为“Service Locator”。“DI容器”和“Service Locator”实际上是同一事物在不同设计模型中的不同称谓罢了，那么DI和Service Locator之间的差异体现在什么地方呢？ 我们觉得可以从“DI容器”和“Service Locator”被谁使用的角度来区分这两种设计模式的差别。在一个采用依赖注入的应用中，我们只需要采用标准的注入形式将服务类型定义好，并在应用启动之前完成相应的服务注册就可以了，框架自身的引擎在运行过程中会利用DI容器来提供当前所需的服务实例。换句话说，DI容器的使用者应该是框架而不是应用程序。Service Locator模式显然不是这样，很明显是应用程序在利用它来提供所需的服务实例，所以它的使用者是应用程序。 我们也可以从另外一个角度区分两者之间的差别。由于依赖服务是以“注入”的方式来提供的，所以采用依赖注入模式的应用可以看成是将服务“推”给DI容器，Service Locator模式下的应用则是利用Service Locator去“拉”取所需的服务，这一推一拉也准确地体现了两者之间的差异。那么既然两者之间有差别，究竟孰优孰劣呢？ 早在2010年，Mark Seemann就在它的博客中将Service Locator视为一种“反模式（Anti-Pattern）”，虽然也有人对此提出不同的意见，但我个人是非常不推荐使用这种设计模式的。我反对使用Service Locator与上面提到的反对使用属性注入和方法注入具有类似的缘由。 我们既然将一组相关的操作定义在一个能够复用的服务中，不但要求服务自身具有独立和自治的特性，也要求服务之间的应该具有明确的边界，服务之间的依赖关系应该是明确的而不是模糊的。不论是采用属性注入或者构造器注入，还是使用Service Locator来提供当前依赖的服务，这无疑为当前的应用增添了一个新的依赖，即针对DI容器或者Service Locator的依赖。 当前服务针对另一个服务的依赖与针对DI容器或者Service Locator的依赖具有本质的不同，前者是一种基于类型的依赖，不论是基于服务的接口还是实现类型，这是一种基于“契约”的依赖。这种依赖不仅是明确的，也是有保障的。但是DI容器也好，Service Locator也罢，它们本质上都是一个黑盒，它能够提供所需服务的前提已经预先添加了对应的服务注册。 正因为如此，ASP.NET Core框架使用的DI框架只支持构造器注入，而不支持属性和方法注入（类似于Startup和中间件基于约定的方法注入除外）。但是我们很有可能不知不觉地会按照Service Locator模式来编写我们的代码，从某种意义上讲，当我们在程序中使用IServiceProvider（表示DI容器）来提取某个服务实例的时候，就意味着我们已经在使用Service Locator模式了，所以当我们遇到这种情况下的时候应该多想一想是否一定需要这么做。虽然我们提倡尽可能避免使用Service Locator模式，但是有的时候（有其是在编写框架或者组件的时候），我们是无法避免使用IServiceProvider来提取服务。 4. .Net Core中的DI .NET Core针对依赖注入的编程主要体现在两个方面： 服务注册：创建一个ServiceCollection对象并将服务注册信息以ServiceDescriptor对象的形式添加其中 服务消费： 通过ServiceCollection对象创建对应的ServiceProvider并利用它提供我们需要的服务实例 我们将在后续章节中对服务注册和服务消费进行详细的阐述。 参考文献 https://www.cnblogs.com/artech/p/net-core-di-03.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-register.html":{"url":"pages/di-register.html","title":"3.5 服务注册","keywords":"","body":".Net Core 服务注册 .Net Core 服务注册 1. ServiceDescriptor 2. IServiceCollection 1) Add 2) Add{Lifetime} 3) TryAdd 4) TryAdd{Lifetime} 5) TryAddEnumerable 6) RemoveAll & Replace 服务注册本质是创建相应的ServiceDescriptor对象并将其添加到指定IServiceCollection集合对象中的过程。 1. ServiceDescriptor ServiceDescriptor提供对服务的描述信息，这些信息将指导ServiceProvider正确地实施服务提供操作。 public class ServiceDescriptor { public Type ServiceType { get; } public ServiceLifetime Lifetime { get; } public Type ImplementationType { get; } public Func ImplementationFactory { get; } public object ImplementationInstance { get; } public ServiceDescriptor(Type serviceType, object instance); public ServiceDescriptor(Type serviceType, Func factory, ServiceLifetime lifetime); public ServiceDescriptor(Type serviceType, Type implementationType, ServiceLifetime lifetime); } ServiceType属性代表提供服务的类型，由于标准化的服务一般会定义成接口，所以在绝大部分情况下体现为一个接口类型。 类型为ServiceLifetime的属性Lifetime体现了ServiceProvider针对服务实例生命周期的控制方式。如下面的代码片段所示，ServiceLifetime是一个枚举类型，定义其中的三个选项（Singleton、Scoped和Transient）体现三种对服务对象生命周期的控制形式，我们在后续对此作专门的介绍。 public enum ServiceLifetime { Singleton, Scoped, Transient } ServiceDescriptor的其他三个属性体现了服务实例的三种提供方式，并对应着三个构造函数。如果我们指定了服务的实现类型（对应于ImplementationType属性），那么最终的服务实例将通过调用定义在实现类型中某一个构造函数来创建。如果指定的是一个Func对象（对应于ImplementationFactory属性），那么IServiceProvider对象将会将自身作为输入参数调用该委托对象来提供服务实例。如果我们直接指定一个现有的对象（对应的属性为ImplementationInstance），那么该对象就是最终提供的服务实例。 如果我们采用直接提供服务实例的形式来创建ServiceDescriptor对象，意味着服务注册默认采用Singleton生命周期模式。对于通过其他两个构造函数创建的ServiceDescriptor对象来说，则需要显式指定采用的生命周期模式。 除了调用上面介绍的三个构造函数来创建对应的ServiceDescriptor对象之外，我们还可以提供定义在ServiceDescriptor类型中一系列静态方法来创建该对象。如下面的代码片段所示，ServiceDescriptor提供了如下两个名为Describe的方法重载来创建对应的ServiceDescriptor对象。 public class ServiceDescriptor { public static ServiceDescriptor Describe(Type serviceType, Func implementationFactory, ServiceLifetime lifetime); public static ServiceDescriptor Describe(Type serviceType, Type implementationType, ServiceLifetime lifetime); } 当我们调用上面两个Describe方法来创建ServiceDescriptor对象的时候总是需要指定采用的生命周期模式，为了让对象创建变得更加简单，ServiceDescriptor中还定义了一系列针对三种生命周期模式的静态工厂方法。如下所示的是针对Singleton模式的一组Singleton方法重载的定义，针对其他两种模式的Scoped和Transient方法具有类似的定义。 public class ServiceDescriptor { public static ServiceDescriptor Singleton() where TService: class where TImplementation: class, TService; public static ServiceDescriptor Singleton(Func implementationFactory) where TService: class where TImplementation: class, TService; public static ServiceDescriptor Singleton(Func implementationFactory) where TService: class; public static ServiceDescriptor Singleton(TService implementationInstance) where TService: class; public static ServiceDescriptor Singleton(Type serviceType, Func implementationFactory); public static ServiceDescriptor Singleton(Type serviceType, object implementationInstance); public static ServiceDescriptor Singleton(Type service, Type implementationType); } 2. IServiceCollection IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表。在默认情况下我们使用的是实现该接口的ServiceCollection类型。 public interface IServiceCollection : IList {} public class ServiceCollection : IServiceCollection {} 1) Add 考虑到服务注册是一个高频调用的操作，所以DI框架为IServiceCollection接口定义了一系列扩展方法完成服务注册的工作，比如下面的这两个Add方法可以将指定的一个或者多个ServiceDescriptor对象添加到IServiceCollection集合中。 public static class ServiceCollectionDescriptorExtensions { public static IServiceCollection Add(this IServiceCollection collection, ServiceDescriptor descriptor); public static IServiceCollection Add(this IServiceCollection collection, IEnumerable descriptors); } 2) Add{Lifetime} DI框架还针对具体生命周期模式为IServiceCollection接口定义了一系列的扩展方法，它们会根据提供的输入创建出对应的ServiceDescriptor对象并将其添加到指定的IServiceCollection对象中。如下所示的是针对Singleton模式的AddSingleton方法重载的定义，针对其他两个生命周期模式的AddScoped和AddTransient方法具有类似的定义。 public static class ServiceCollectionServiceExtensions { public static IServiceCollection AddSingleton(this IServiceCollection services) where TService: class; public static IServiceCollection AddSingleton(this IServiceCollection services) where TService: class where TImplementation: class, TService; public static IServiceCollection AddSingleton(this IServiceCollection services, TService implementationInstance) where TService: class; public static IServiceCollection AddSingleton(this IServiceCollection services, Func implementationFactory) where TService: class where TImplementation: class, TService; public static IServiceCollection AddSingleton(this IServiceCollection services, Func implementationFactory) where TService: class; public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType); public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType, Func implementationFactory); public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType, object implementationInstance); public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType, Type implementationType); } 3) TryAdd 虽然针对同一个服务类型可以添加多个ServiceDescriptor，但这情况只有在应用需要使用到同一类型的多个服务实例的情况下才有意义，比如我们可以注册多个ServiceDescriptor来提供同一个主题的多个订阅者。如果我们总是根据指定的服务类型来提取单一的服务实例，这种情况下一个服务类型只需要一个ServiceDescriptor对象就够了。对于这种场景我们可能会使用如下两个名为TryAdd的扩展方法，该方法会根据指定ServiceDescriptor提供的服务类型判断对应的服务注册是否存在，只有不存在指定类型的服务注册情况下，我们提供的ServiceDescriptor才会被添加到指定的IServiceCollection对象中。 public static class ServiceCollectionDescriptorExtensions { public static void TryAdd(this IServiceCollection collection, ServiceDescriptor descriptor); public static void TryAdd(this IServiceCollection collection, IEnumerable descriptors); } 4) TryAdd{Lifetime} 扩展方法TryAdd同样具有基于三种生命周期模式的版本，如下所示的针对Singleton模式的TryAddSingleton方法的定义。在指定服务类型对应的ServiceDescriptor不存在的情况下，它们会采用提供的实现类型、服务实例创建工厂以及服务实例来创建生命周期模式为Singleton的ServiceDescriptor对象并将其添加到指定的IServiceCollection对象中。针对其他两种生命周期模式的TryAddScoped和TryAddTransient方法具有类似的定义。 public static class ServiceCollectionDescriptorExtensions { public static void TryAddSingleton(this IServiceCollection collection) where TService: class; public static void TryAddSingleton(this IServiceCollection collection) where TService: class where TImplementation: class, TService; public static void TryAddSingleton(this IServiceCollection collection, Type service); public static void TryAddSingleton(this IServiceCollection collection, TService instance) where TService: class; public static void TryAddSingleton(this IServiceCollection services, Func implementationFactory) where TService: class; public static void TryAddSingleton(this IServiceCollection collection, Type service, Func implementationFactory); public static void TryAddSingleton(this IServiceCollection collection, Type service, Type implementationType); } 5) TryAddEnumerable 除了上面介绍的扩展方法TryAdd和TryAdd{Lifetime}之外，IServiceCollection接口还具有如下两个名为TryAddEnumerable的扩展方法。当TryAddEnumerable方法在决定将指定的ServiceDescriptor添加到IServiceCollection对象之前，它也会做存在性检验。与TryAdd和TryAdd{Lifetime}方法不同的是，该方法在判断执行的ServiceDescriptor是否存在时会同时考虑服务类型和实现类型。 public static class ServiceCollectionDescriptorExtensions { public static void TryAddEnumerable(this IServiceCollection services, ServiceDescriptor descriptor); public static void TryAddEnumerable(this IServiceCollection services, IEnumerable descriptors); } TryAddEnumerable判断存在性的实现类型不只是ServiceDescriptor的ImplementationType属性。如果ServiceDescriptor是通过一个指定的服务实例创建的，那么该实例的类型会作为用来判断存在与否的实现类型。如果ServiceDescriptor是服务实例工厂来创建的，那么代表服务实例创建工厂的Func对象的第二个参数类型将被用于判断ServiceDescriptor的存在性。扩展方法TryAddEnumerable的实现逻辑可以通过如下这段程序来验证。 var services = new ServiceCollection(); services.TryAddEnumerable(ServiceDescriptor.Singleton()); Debug.Assert(services.Count == 1); services.TryAddEnumerable(ServiceDescriptor.Singleton()); Debug.Assert(services.Count == 1); services.TryAddEnumerable(ServiceDescriptor.Singleton(new Foo())); Debug.Assert(services.Count == 1); Func factory4Foo = _ => new Foo(); services.TryAddEnumerable(ServiceDescriptor.Singleton(factory4Foo)); Debug.Assert(services.Count == 1); services.TryAddEnumerable(ServiceDescriptor.Singleton()); Debug.Assert(services.Count == 2); services.TryAddEnumerable(ServiceDescriptor.Singleton(new Baz())); Debug.Assert(services.Count == 3); Func factory4Gux = _ => new Gux(); services.TryAddEnumerable(ServiceDescriptor.Singleton(factory4Gux)); Debug.Assert(services.Count == 4); 如果通过上述策略得到的实现类型为Object，那么TryAddEnumerable会因为实现类型不明确而抛出一个ArgumentException类型的异常。这种情况主要发生在提供的ServiceDescriptor对象是由服务实例工厂创建的情况，所以上面实例中用来创建ServiceDescriptor的工厂类型分别为Func和Func，而不是Func。 var service = ServiceDescriptor.Singleton(_ => new Foo()); new ServiceCollection().TryAddEnumerable(service); 假设我们采用如上所示的方式利用一个Lamda表达式来创建一个ServiceDescriptor对象，对于创建的ServiceDescriptor来说，其服务实例工厂是一个Func对象，所以当我们将它作为参数调用TryAddEnumerable方法的会抛出如下图所示的ArgumentException异常。 6) RemoveAll & Replace 上面介绍的这些方法最终的目的都是添加新的ServiceDescriptor到指定的IServiceCollection对象中，有的时候我们还希望删除或者替换现有的某个ServiceDescriptor，这种情况下通常发生在需要对当前使用框架中由某个服务提供的功能进行定制的时候。由于IServiceCollection实现了IList接口，所以我们可以调用其Clear、Remove和RemoveAt方法来清除或者删除现有的ServiceDescriptor。除此之外，我们还可以选择如下这些扩展方法。 public static class ServiceCollectionDescriptorExtensions { public static IServiceCollection RemoveAll( this IServiceCollection collection); public static IServiceCollection RemoveAll(this IServiceCollection collection, Type serviceType); public static IServiceCollection Replace(this IServiceCollection collection, ServiceDescriptor descriptor); } RemoveAll和RemoveAll方法帮助我们针对指定的服务类型来删除添加的ServiceDescriptor。Replace方法会使用指定的ServiceDescriptor去替换第一个具有相同服务类型（对应ServiceType属性）的ServiceDescriptor，实际操作是先删除后添加。如果从目前的IServiceCollection中找不到服务类型匹配的ServiceDescriptor，指定的ServiceDescriptor会直接添加到IServiceCollection对象中，这一逻辑也可以利用如下的程序来验证。 var services = new ServiceCollection(); services.Replace(ServiceDescriptor.Singleton()); Debug.Assert(services.Any(it => it.ImplementationType == typeof(Foo))); services.AddSingleton(); services.Replace(ServiceDescriptor.Singleton()); Debug.Assert(!services.Any(it=>it.ImplementationType == typeof(Foo))); Debug.Assert(services.Any(it => it.ImplementationType == typeof(Bar))); Debug.Assert(services.Any(it => it.ImplementationType == typeof(Baz))); 参考文献 https://www.cnblogs.com/artech/p/net-core-di-07.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-consume.html":{"url":"pages/di-consume.html","title":"3.6 服务消费","keywords":"","body":".Net Core 服务消费 1. ServiceProvider 2. 消费服务 3. 服务集合 4. 泛型支持 5. 构造函数选择 1. ServiceProvider 在采用了依赖注入的应用中，我们总是直接利用DI容器直接获取所需的服务实例，换句话说，DI容器起到了一个服务提供者的角色，它能够根据我们提供的服务描述信息提供一个可用的服务对象。 作为一个服务的提供者，ASP.NET Core中的DI容器最终体现为一个IServiceProvider接口。此接口只声明了一个GetService方法以根据指定的服务类型来提供对应的服务实例。 public interface IServiceProvider { object GetService(Type serviceType); } public static class ServiceCollectionContainerBuilderExtensions { public static ServiceProvider BuildServiceProvider(this IServiceCollection services); } ASP.NET Core内部真正使用的是一个实现了IServiceProvider接口的内部类型（该类型的名称为“ServiceProvider”），我们不能直接创建该对象，只能间接地通过调用IServiceCollection接口的扩展方法BuildServiceProvider得到它。 由于ASP.NET Core中的ServiceProvider是根据一个代表ServiceDescriptor集合的IServiceCollection对象创建的，当我们调用其GetService方法的时候，它会根据我们提供的服务类型找到对应的ServiceDecriptor对象。如果该ServiceDecriptor对象的ImplementationInstance属性返回一个具体的对象，该对象将直接用服务实例。如果ServiceDecriptor对象的ImplementationFactory返回一个具体的委托，该委托对象将直接用作创建服务实例的工厂。如果这两个属性均为Null，ServiceProvider才会根据ImplementationType属性返回的类型调用相应的构造函数创建被提供的服务实例。ServiceProvider仅仅支持构造器注入，属性注入和方法注入的支持并未提供。 除了定义在IServiceProvider的这个GetService方法，DI框架为该接口定了如下这些扩展方法。GetService方法会以泛型参数的形式指定服务类型，返回的服务实例也会作对应的类型转换。如果指定服务类型的服务注册不存在，GetService方法会返回Null，如果调用GetRequiredService或者GetRequiredService方法则会抛出一个InvalidOperationException类型的异常。如果所需的服务实例是必需的，我们一般会调用这两个扩展方法。 public static class ServiceProviderServiceExtensions { public static T GetService(this IServiceProvider provider); public static T GetRequiredService(this IServiceProvider provider); public static object GetRequiredService(this IServiceProvider provider, Type serviceType); public static IEnumerable GetServices(this IServiceProvider provider); public static IEnumerable GetServices(this IServiceProvider provider, Type serviceType); } 2. 消费服务 接下来采用实例演示的方式来介绍如何利用ServiceCollection进行服务注册，以及如何利用ServiceCollection创建对应的ServiceProvider来提供我们需要的服务实例。 定义四个服务接口（IFoo、IBar、IBaz和IGux）以及分别实现它们的四个服务类（Foo、Bar、Baz和Gux）如下面的代码片段所示，IGux具有三个只读属性（Foo、Bar和Baz）均为接口类型，并在构造函数中进行初始化。 public interface IFoo {} public interface IBar {} public interface IBaz {} public interface IGux { IFoo Foo { get; } IBar Bar { get; } IBaz Baz { get; } } public class Foo : IFoo {} public class Bar : IBar {} public class Baz : IBaz {} public class Gux : IGux { public IFoo Foo { get; private set; } public IBar Bar { get; private set; } public IBaz Baz { get; private set; } public Gux(IFoo foo, IBar bar, IBaz baz) { this.Foo = foo; this.Bar = bar; this.Baz = baz; } } 现在我们在作为程序入口的Main方法中创建了一个ServiceCollection对象，并采用不同的方式完成了针对四个服务接口的注册。具体来说，对于服务接口IFoo和IGux的ServiceDescriptor来说，我们指定了代表服务真实类型的ImplementationType属性，而对于针对服务接口IBar和IBaz的ServiceDescriptor来说，我们初始化的则是分别代表服务实例和服务工厂的ImplementationInstance和ImplementationFactory属性。由于我们调用的是AddSingleton方法，所以四个ServiceDescriptor的Lifetime属性均为Singleton。 class Program { static void Main(string[] args) { IServiceCollection services = new ServiceCollection() .AddSingleton() .AddSingleton(new Bar()) .AddSingleton(_ => new Baz()) .AddSingleton(); IServiceProvider serviceProvider = services.BuildServiceProvider(); Console.WriteLine(\"serviceProvider.GetService(): {0}\",serviceProvider.GetService()); Console.WriteLine(\"serviceProvider.GetService(): {0}\", serviceProvider.GetService()); Console.WriteLine(\"serviceProvider.GetService(): {0}\", serviceProvider.GetService()); Console.WriteLine(\"serviceProvider.GetService(): {0}\", serviceProvider.GetService()); } } 接下来我们调用ServiceCollection对象的扩展方法BuildServiceProvider得到对应的ServiceProvider对象，然后调用其扩展方法GetService分别获得针对四个接口的服务实例对象并将类型名称输出到控制台上。运行该程序之后，我们会在控制台上得到如下的输出结果，由此印证ServiceProvider为我们提供了我们期望的服务实例。 serviceProvider.GetService(): Foo serviceProvider.GetService(): Bar serviceProvider.GetService(): Baz serviceProvider.GetService(): Gux 3. 服务集合 如果我们在调用GetService方法的时候将服务类型指定为IEnumerable，那么返回的结果将会是一个集合对象。除此之外，我们可以直接调用IServiceProvider如下两个扩展方法GetServeces达到相同的目的。在这种情况下，ServiceProvider将会利用所有与指定服务类型相匹配的ServiceDescriptor来提供具体的服务实例，这些均会作为返回的集合对象的元素。如果所有的ServiceDescriptor均与指定的服务类型不匹配，那么最终返回的是一个空的集合对象。 public static class ServiceProviderExtensions { public static IEnumerable GetServices(this IServiceProvider provider); public static IEnumerable GetServices(this IServiceProvider provider, Type serviceType); } 值得一提的是，如果ServiceProvider所在的ServiceCollection包含多个具有相同服务类型（对应ServiceType属性）的ServiceDescriptor，当我们调用GetService方法获取单个服务实例的时候，只有最后一个ServiceDescriptor才是有效的，至于其他的ServiceDescriptor，它们只有在获取服务集合的场景下才有意义。 我们通过一个简单的实例来演示如何利用ServiceProvider得到一个包含多个服务实例的集合。我们在一个控制台应用中定义了如下一个服务接口IFoobar，两个服务类型Foo和Bar均实现了这个接口。在作为程序入口的Main方法中，我们将针针对服务类型Foo和Bar的两个ServiceDescriptor添加到创建的ServiceCollection对象中，这两个ServiceDescriptor对象的ServiceType属性均为IFoobar。 class Program { static void Main(string[] args) { IServiceCollection serviceCollection = new ServiceCollection() .AddSingleton() .AddSingleton(); IServiceProvider serviceProvider = serviceCollection.BuildServiceProvider(); Console.WriteLine(\"serviceProvider.GetService(): {0}\", serviceProvider.GetService()); IEnumerable services = serviceProvider.GetServices(); int index = 1; Console.WriteLine(\"serviceProvider.GetServices():\"); foreach (IFoobar foobar in services) { Console.WriteLine(\"{0}: {1}\", index++, foobar); } } } public interface IFoobar {} public class Foo : IFoobar {} public class Bar : IFoobar {} 在调用ServiceCollection对象的扩展方法BuildServiceProvider得到对应的ServiceProvider对象之后，我们先调用其GetService方法以确定针对服务接口IFoobar得到的服务实例的真实类型就是是Foo还是Bar。接下来我们调用ServiceProvider的扩展方法GetServices获取一组针对服务接口IFoobar的服务实例并将它们的真是类型打印在控制台上。该程序运行后将会在控制台上生成如下的输出结果。 serviceProvider.GetService(): Bar serviceProvider.GetServices(): Foo Bar 4. 泛型支持 ServiceProvider提供的服务实例不仅限于普通的类型，它对泛型服务类型同样支持。在针对泛型服务进行注册的时候，我们可以将服务类型设定为携带具体泛型参数的“关闭泛型类型”（比如IFoobar），除此之外服务类型也可以是包含具体泛型参数的“开放泛型类型”（比如IFoo）。前者实际上还是将其视为非泛型服务来对待，后者才真正体现了“泛型”的本质。 比如我们注册了某个泛型服务接口IFoobar与它的实现类Foobar之间的映射关系，当我们指定一个携带具体泛型参数的服务接口类型IFoobar并调用ServiceProvider的GetService方法获取对应的服务实例时，ServiceProvider会针对指定的泛型参数类型(IFoo和IBar)来解析与之匹配的实现类型（可能是Foo和Bar）并得到最终的实现类型（Foobar）。 我们同样利用一个简单的控制台应用来演示基于泛型的服务注册与提供方式。如下面的代码片段所示，我们定义了三个服务接口（IFoo、IBar和IFoobar）和实现它们的三个服务类（Foo、Bar个Foobar）,泛型接口具有两个泛型参数类型的属性（Foo和Bar），它们在实现类中以构造器注入的方式被初始化。 class Program { static void Main(string[] args) { IServiceProvider serviceProvider = new ServiceCollection() .AddTransient() .AddTransient() .AddTransient(typeof(IFoobar), typeof(Foobar)) .BuildServiceProvider(); Console.WriteLine(\"serviceProvider.GetService>().Foo: {0}\", serviceProvider.GetService>().Foo); Console.WriteLine(\"serviceProvider.GetService>().Bar: {0}\", serviceProvider.GetService>().Bar); } } public interface IFoobar { T1 Foo { get; } T2 Bar { get; } } public interface IFoo {} public interface IBar {} public class Foobar : IFoobar { public T1 Foo { get; private set; } public T2 Bar { get; private set; } public Foobar(T1 foo, T2 bar) { this.Foo = foo; this.Bar = bar; } } public class Foo : IFoo {} public class Bar : IBar {} 在作为入口程序的Main方法中，我们创建了一个ServiceCollection对象并采用Transient模式注册了上述三个服务接口与对应实现类型之间的映射关系，对于泛型服务IFoobar/Foobar来说，我们指定的是不携带具体泛型参数的开放泛型类型IFoobar/Foobar。利用此ServiceCollection创建出对应的ServiceProvider之后，我们调用后者的GetService方法并指定IFoobar为服务类型。得到的服务对象将会是一个Foobar对象，我们将它的Foo和Bar属性类型输出于控制台上作为验证。该程序执行之后将会在控制台上产生下所示的输出结果。 serviceProvider.GetService>().Foo: Foo serviceProvider.GetService>().Bar: Bar 5. 构造函数选择 当ServiceProvider利用ImplementationType属性返回的真实类型的构造函数来创建最终的服务实例时，如果服务的真实类型定义了多个构造函数，那么ServiceProvider针对构造函数的选择会采用怎样的策略呢？ 如果ServiceProvider试图通过调用构造函数的方式来创建服务实例，传入构造函数的所有参数必须先被初始化，最终被选择出来的构造函数必须具备一个基本的条件：ServiceProvider能够提供构造函数的所有参数。 我们在一个控制台应用中定义了四个服务接口（IFoo、IBar、IBaz和IGux）以及实现它们的四个服务类（Foo、Bar、Baz和Gux）。如下面的代码片段所示，我们为Gux定义了三个构造函数，参数均为我们定义了服务接口类型。为了确定ServiceProvider最终选择哪个构造函数来创建目标服务实例，我们在构造函数执行时在控制台上输出相应的指示性文字。 public interface IFoo {} public interface IBar {} public interface IBaz {} public interface IGux {} public class Foo : IFoo {} public class Bar : IBar {} public class Baz : IBaz {} public class Gux : IGux { public Gux(IFoo foo) { Console.WriteLine(\"Gux(IFoo)\"); } public Gux(IFoo foo, IBar bar) { Console.WriteLine(\"Gux(IFoo, IBar)\"); } public Gux(IFoo foo, IBar bar, IBaz baz) { Console.WriteLine(\"Gux(IFoo, IBar, IBaz)\"); } } 我们在作为程序入口的Main方法中创建一个ServiceCollection对象并在其中添加针对IFoo、IBar以及IGux这三个服务接口的服务注册，针对服务接口IBaz的注册并未被添加。我们利用由它创建的ServiceProvider来提供针对服务接口IGux的实例，究竟能否得到一个Gux对象呢？如果可以，它又是通过执行哪个构造函数创建的呢？ class Program { static void Main(string[] args) { new ServiceCollection() .AddTransient() .AddTransient() .AddTransient() .BuildServiceProvider() .GetServices(); } } 对于定义在Gux中的三个构造函数来说，ServiceProvider所在的ServiceCollection包含针对接口IFoo和IBar的服务注册，所以它能够提供前面两个构造函数的所有参数。由于第三个构造函数具有一个类型为IBaz的参数，这无法通过ServiceProvider来提供。根据我们上面介绍的第一个原则（ServiceProvider能够提供构造函数的所有参数），Gux的前两个构造函数会成为合法的候选构造函数，那么ServiceProvider最终会选择哪一个呢？ 在所有合法的候选构造函数列表中，最终被选择出来的构造函数具有这么一个特征：每一个候选构造函数的参数类型集合都是这个构造函数参数类型集合的子集。如果这样的构造函数并不存在，一个类型为InvalidOperationException的异常会被抛出来。根据这个原则，Gux的第二个构造函数的参数类型包括IFoo和IBar，而第一个构造函数仅仅具有一个类型为IFoo的参数，最终被选择出来的会是Gux的第二个构造函数，所有运行我们的实例程序将会在控制台上产生如下的输出结果。 Gux(IFoo, IBar) 接下来我们对实例程序略加改动。如下面的代码片段所示，我们只为Gux定义两个构造函数，它们都具有两个参数，参数类型分别为IFoo&IBar和IBar&IBaz。在Main方法中，我们将针对IBaz/Baz的服务注册添加到创建的ServiceCollection上。 class Program { static void Main(string[] args) { new ServiceCollection() .AddTransient() .AddTransient() .AddTransient() .AddTransient() .BuildServiceProvider() .GetServices(); } } public class Gux : IGux { public Gux(IFoo foo, IBar bar) {} public Gux(IBar bar, IBaz baz) {} } 对于Gux的两个构造函数，虽然它们的参数均能够由ServiceProvider来提供，但是并没有一个构造函数的参数类型集合能够成为所有有效构造函数参数类型集合的超集，所以ServiceProvider无法选择出一个最佳的构造函数。如果我们运行这个程序，一个InvalidOperationException异常会被抛出来，控制台上将呈现出如下所示的错误消息。 Unhandled Exception: System.InvalidOperationException: Unable to activate type 'Gux'. The following constructors are ambigious: Void .ctor(IFoo, IBar) Void .ctor(IBar, IBaz) ... 参考文献 http://www.cnblogs.com/artech/p/asp-net-core-di-register.html http://www.cnblogs.com/artech/p/asp-net-core-di-life-time.html https://www.cnblogs.com/artech/p/net-core-di-08.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-lifetime.html":{"url":"pages/di-lifetime.html","title":"3.7 服务生命周期","keywords":"","body":"服务生命周期 1. 服务范围 2. 生命周期管理模式 3. 服务对象回收 4. Asp.Net Core 服务生命周期 5. ASP.NET Core 服务范围检验 生命周期决定了ServiceProvider采用怎样的方式创建和回收服务实例。ServiceProvider具有三种基本的生命周期管理模式，分别对应着枚举类型ServiceLifetime的三个选项（Singleton、Scoped和Transient）。对于ServiceProvider支持的这三种生命周期管理模式，Singleton和Transient的语义很明确，前者（Singleton）表示以“单例”的方式管理服务实例的生命周期，意味着ServiceProvider对象多次针对同一个服务类型所提供的服务实例实际上是同一个对象；而后者（Transient）则完全相反，对于每次服务提供请求，ServiceProvider总会创建一个新的对象。那么Scoped又体现了ServiceProvider针对服务实例怎样的生命周期管理方式呢？ 1. 服务范围 Scoped代表一种怎样的生命周期模式，很多初学者往往搞不清楚。这里所谓的Scope指的是由IServiceScope接口表示的“服务范围”，该范围由IServiceScopeFactory接口表示的“服务范围工厂”来创建。如下面的代码片段所示，IServiceProvider的扩展方法CreateScope正是利用提供的IServiceScopeFactory服务实例来创建作为服务范围的IServiceScope对象。 public interface IServiceScope : IDisposable { IServiceProvider ServiceProvider { get; } } public interface IServiceScopeFactory { IServiceScope CreateScope(); } public static class ServiceProviderServiceExtensions { public static IServiceScope CreateScope(this IServiceProvider provider) => provider.GetRequiredService().CreateScope(); } ServiceScope为某个ServiceProvider对象圈定了一个“作用域”，枚举类型ServiceLifetime中的Scoped选项指的就是这么一个ServiceScope。若要充分理解ServiceScope和ServiceProvider之间的关系，我们需要简单了解一下ServiceProvider的层级结构。除了直接通过一个ServiceCollection对象创建一个独立的ServiceProvider对象之外，一个ServiceProvider还可以根据另一个ServiceProvider对象来创建，如果采用后一种创建方式，我们指定的ServiceProvider与创建的ServiceProvider将成为一种“父子”关系。 internal class ServiceProvider : IServiceProvider, IDisposable { private readonly ServiceProvider _root; internal ServiceProvider(ServiceProvider parent) { _root = parent._root; } //其他成员 } 虽然在创建过程中体现了ServiceProvider之间存在着一种树形化的层级结构，但是ServiceProvider对象本身并没有一个指向“父亲”的引用，它仅仅会保留针对根节点的引用。如上面的代码片段所示，针对根节点的引用体现为ServiceProvider类的字段_root。当我们根据作为“父亲”的ServiceProvider创建一个新的ServiceProvider的时候，父子均指向同一个“根”。我们可以将创建过程中体现的层级化关系称为“逻辑关系”，而将ServiceProvider对象自身的引用关系称为“物理关系”，下图清楚地揭示了这两种关系之间的转化。 由于ServiceProvider自身是一个内部类型，我们不能采用调用构造函数的方式根据一个作为“父亲”的ServiceProvider创建另一个作为“儿子”的ServiceProvider，但是这个目的可以间接地通过创建ServiceScope的方式来完成。如下面的代码片段所示，我们首先创建一个独立的ServiceProvider并调用其CreateScope方法创建一个新的ServiceScope，它的ServiceProvider就是前者的“儿子”。 class Program { static void Main(string[] args) { IServiceProvider serviceProvider1 = new ServiceCollection().BuildServiceProvider(); IServiceProvider serviceProvider2 = serviceProvider1.CreateScope().ServiceProvider; object root = serviceProvider2.GetType().GetField(\"_root\", BindingFlags.Instance| BindingFlags.NonPublic).GetValue(serviceProvider2); Debug.Assert(object.ReferenceEquals(serviceProvider1, root)); } } 如果读者朋友们希望进一步了解ServiceScope的创建以及它和ServiceProvider之间的关系，我们不妨先来看看作为IServiceScope接口默认实现的内部类型ServiceScope的定义。如下面的代码片段所示，ServiceScope仅仅是对一个ServiceProvider对象的简单封装而已。值得一提的是，当ServiceScope的Dispose方法被调用的时候，这个被封装的ServiceProvider的同名方法同时被执行。 internal class ServiceScope : IServiceScope { private readonly ServiceProvider _scopedProvider; public ServiceScope(ServiceProvider scopedProvider) { this._scopedProvider = scopedProvider; } public void Dispose() { _scopedProvider.Dispose(); } public IServiceProvider ServiceProvider { get {return _scopedProvider; } } } IServiceScopeFactory接口的默认实现类型是一个名为ServiceScopeFactory的内部类型。如下面的代码片段所示，ServiceScopeFactory的只读字段“_provider”表示当前的ServiceProvider。当CreateScope方法被调用的时候，这个ServiceProvider的“子ServiceProvider”被创建出来，并被封装成返回的ServiceScope对象。 internal class ServiceScopeFactory : IServiceScopeFactory { private readonly ServiceProvider _provider; public ServiceScopeFactory(ServiceProvider provider) { _provider = provider; } public IServiceScope CreateScope() { return new ServiceScope(new ServiceProvider(_provider)); } } 2. 生命周期管理模式 只有在充分了解ServiceScope的创建过程以及它与ServiceProvider之间的关系之后，我们才会对ServiceProvider支持的三种生命周期管理模式（Singleton、Scope和Transient）具有深刻的认识。就服务实例的提供方式来说，它们之间具有如下的差异： Singleton：IServiceProvider创建的服务实例保存在作为根容器的IServiceProvider上，所有多个同根的IServiceProvider对象提供的针对同一类型的服务实例都是同一个对象。 Scoped：IServiceProvider创建的服务实例由自己保存，所以同一个IServiceProvider对象提供的针对同一类型的服务实例均是同一个对象。 Transient：针对每一次服务提供请求，IServiceProvider总是创建一个新的服务实例。 在一个控制台应用中定义了如下三个服务接口（IFoo、IBar和IBaz）以及分别实现它们的三个服务类(Foo、Bar和Baz)。 public interface IFoo {} public interface IBar {} public interface IBaz {} public class Foo : IFoo {} public class Bar : IBar {} public class Baz : IBaz {} 现在我们在作为程序入口的Main方法中创建一个ServiceCollection对象，并采用不同的生命周期管理模式完成针对三个服务接口的注册(IFoo/Foo、IBar/Bar和IBaz/Baz分别Transient、Scoped和Singleton)。我们接下来针对这个ServiceCollection对象创建一个ServiceProvider（root），并采用创建ServiceScope的方式创建它的两个“子ServiceProvider”（child1和child2）。 class Program { static void Main(string[] args) { IServiceProvider root = new ServiceCollection() .AddTransient() .AddScoped() .AddSingleton() .BuildServiceProvider(); IServiceProvider child1 = root.CreateScope().ServiceProvider; IServiceProvider child2 = root.CreateScope().ServiceProvider; Console.WriteLine(\"ReferenceEquals(root.GetService(), root.GetService() = {0}\",ReferenceEquals(root.GetService(), root.GetService())); Console.WriteLine(\"ReferenceEquals(child1.GetService(), child1.GetService() = {0}\",ReferenceEquals(child1.GetService(), child1.GetService())); Console.WriteLine(\"ReferenceEquals(child1.GetService(), child2.GetService() = {0}\",ReferenceEquals(child1.GetService(), child2.GetService())); Console.WriteLine(\"ReferenceEquals(child1.GetService(), child2.GetService() = {0}\",ReferenceEquals(child1.GetService(), child2.GetService())); } } 为了验证ServiceProvider针对Transient模式是否总是创建新的服务实例，我们利用同一个ServiceProvider（root）获取针对服务接口IFoo的实例并进行比较。为了验证ServiceProvider针对Scope模式是否仅仅在当前ServiceScope下具有“单例”的特性，我们先后比较了同一个ServiceProvider（child1）和不同ServiceProvider（child1和child2）两次针对服务接口IBar获取的实例。为了验证具有“同根”的所有ServiceProvider针对Singleton模式总是返回同一个服务实例，我们比较了两个不同child1和child2两次针对服务接口IBaz获取的服务实例。如下所示的输出结构印证了我们上面的论述。 ReferenceEquals(root.GetService(), root.GetService() = False ReferenceEquals(child1.GetService(), child1.GetService() = True ReferenceEquals(child1.GetService(), child2.GetService() = False ReferenceEquals(child1.GetService(), child2.GetService() = True 3. 服务对象回收 ServiceProvider除了为我们提供所需的服务实例之外，对于由它提供的服务实例，它还肩负起回收之责。这里所说的回收与.NET自身的垃圾回收机制无关，仅仅针对于自身类型实现了IDisposable接口的服务实例，所谓的回收仅仅体现为调用它们的Dispose方法。ServiceProvider针对服务实例所采用的回收策略取决于服务注册时采用的生命周期管理模式，具体采用的服务回收策略主要体现为如下两点： Singleton：提供Disposable服务实例保存在作为根容器的IServiceProvider对象上，只有后者被释放的时候这些Disposable服务实例才能被释放。 Scoped和Transient：IServiceProvider对象会保存由它提供的Disposable服务实例，当自己被释放的时候，这些Disposable会被释放。 综上所述，每个作为DI容器的IServiceProvider对象都具有如下图所示两个列表来存放服务实例，我们将它们分别命名为“Realized Services”和“Disposable Services”，对于一个作为非根容器的IServiceProvider对象来说，由它提供的Scoped服务保存在自身的Realized Services列表中，Singleton服务实例则会保存在根容器的Realized Services列表。如果服务实现类型实现了IDisposable接口，Scoped和Transient服务实例会被保存到自身的Disposable Services列表中，而Singleton服务实例则会保存到根容器的Disposable Services列表。 当IServiceProvider提供服务实例时，它会提取出对应的ServiceDescriptor对象并读取其生命周期模式。 如果生命周期为Singleton，且根容器Realized Services列表中已包含对应的服务实例，后者将作为最终提供的服务实例。若服务实例尚未创建，那么将创建新服务对象作为提供的服务实例。返回的该服务对象将被添加到根容器Realized Services列表中，如果服务类型实现了IDisposable接口，该实例会添加到根容器的Disposable Services列表中。 如果生命周期为Scoped，那么IServiceProvider会先确定自身的Realized Services列表中是否存在对应的服务实例，存在的服务实例将作为最终返回的服务实例。如果Realized Services列表不存在对应的服务实例，那么将创建新的服务实例。在最终服务实例返回之前，该实例将添加到自身的Realized Services列表中，如果实例类型实现了IDisposable接口，该实例会被添加到自身的Disposable Services列表中。 如果生命周期为Transient，那么IServiceProvider会直接创建一个新的服务实例。在作为最终的服务实例被返回之前，该实例会被添到的自身的Realized Services列表中，如果实例类型实现了IDisposable接口，创建的服务实例会被添加到自身的Disposable Services列表中。 对于非根容器的IServiceProvider对象来说，它的生命周期是由“包裹”着它的IServiceScope对象控制的。从上面给出的定义可以看出IServiceScope实现了IDisposable接口，Dispose方法的执行不仅标志着当前服务范围的终结，也意味着对应IServiceProvider对象生命周期的结束。一旦IServiceProvider因自身Dispose方法的调用而被释放的时候，它会从自身的Disposable Services列表中提取出所有需要被释放的服务实例，并调用它们的Dispose方法。在这之后，Disposable Services和Realized Services列表会被清空，列表中的服务实例和IServiceProvider对象自身会成为垃圾对象被GC回收。 我们通过以下示例来体会。 在控制台应用中定义了如下三个服务接口（IFoo、IBar和IBaz）以及三个实现它们的服务类（Foo、Bar和Baz），这些类型具有相同的基类Disposable。Disposable实现了IDisposable接口，我们在Dispose方法中输出相应的文字以确定对象回收的时机。 public interface IFoo {} public interface IBar {} public interface IBaz {} public class Foo : Disposable, IFoo {} public class Bar : Disposable, IBar {} public class Baz : Disposable, IBaz {} public class Disposable : IDisposable { public void Dispose() { Console.WriteLine(\"{0}.Dispose()\", this.GetType()); } } 我们在作为程序入口的Main方法中创建了一个ServiceCollection对象，并在其中采用不同的生命周期管理模式注册了三个相应的服务（IFoo/Foo、IBar/Bar和IBaz/Baz分别采用Transient、Scoped和Singleton模式）。我们针对这个ServiceCollection创建了一个ServiceProvider（root），以及它的两个“儿子”（child1和child2）。在分别通过child1和child2提供了两个服务实例（child1：IFoo， child2：IBar/IBaz）之后，我们先后调用三个ServiceProvider（child1=>child2=>root）的Dispose方法。 class Program { static void Main(string[] args) { IServiceProvider root = new ServiceCollection() .AddTransient() .AddScoped() .AddSingleton() .BuildServiceProvider(); IServiceProvider child1 = root.CreateScope().ServiceProvider; IServiceProvider child2 = root.CreateScope().ServiceProvider; child1.GetService(); child1.GetService(); child2.GetService(); child2.GetService(); Console.WriteLine(\"child1.Dispose()\"); ((IDisposable)child1).Dispose(); Console.WriteLine(\"child2.Dispose()\"); ((IDisposable)child2).Dispose(); Console.WriteLine(\"root.Dispose()\"); ((IDisposable)root).Dispose(); } } 运行该程序输出结果如下。child1提供的两个Transient模式服务实例，其回收是在child1的Dispose方法执行之后自动完成。当child2的Dispose方法被调用的时候，采用Scope模式的Bar对象被自动回收了，而采用Singleton模式的Baz对象的回收工作，是在root的Dispose方法被调用之后自动完成的。 child1.Dispose() Foo.Dispose() Foo.Dispose() child2.Dispose() Bar.Dispose() root.Dispose() Baz.Dispose() 了解ServiceProvider针对不同生命周期管理模式所采用的服务回收策略还会帮助我们正确的使用它。具体来说，当我们在使用一个现有的ServiceProvider的时候，由于我们并不能直接对它实施回收（因为它同时会在其它地方被使用），如果直接使用它来提供我们所需的服务实例，由于这些服务实例可能会在很长一段时间得不到回收，进而导致一些内存泄漏的问题。如果所用的是一个与当前应用具有相同生命周期（ServiceProvider在应用终止的时候才会被回收）的ServiceProvider，而且提供的服务采用Transient模式，这个问题就更加严重了，这意味着每次提供的服务实例都是一个全新的对象，但是它永远得不到回收。 为了解决这个问题，我想很多人会想到一种解决方案，那就是按照如下所示的方式显式地对提供的每个服务实例实施回收工作。实际上这并不是一种推荐的编程方式，因为这样的做法仅仅确保了服务实例对象的Dispose方法能够被及时调用，但是ServiceProvider依然保持着对服务实例的引用，后者依然不能及时地被GC回收。 public void DoWork(IServiceProvider serviceProvider) { using (IFoobar foobar = serviceProvider.GetService()) { // ... } } 由于提供的服务实例总是被某个ServiceProvider引用着[1]（直接提供服务实例的ServiceProvider或者是它的根），所以服务实例能够被GC从内存及时回收的前提是引用它的ServiceProvider及时地变成垃圾对象。要让提供服务实例的ServiceProvider成为垃圾对象，我们就必须创建一个新的ServiceProvider，通过上面的介绍我们知道ServiceProvider的创建可以通过创建ServiceScope的方式来实现。除此之外，我们可以通过回收ServiceScope的方式来回收对应的ServiceProvider，进而进一步回收由它提供的服务实例（仅限Transient和Scoped模式）。下面的代码片段给出了正确的编程方式。 public void DoWork(IServiceProvider serviceProvider) { using (IServiceScope serviceScope = serviceProvider.CreateScope()) { IFoobar foobar = serviceScope.ServiceProvider.GetService(); // ... } } 接下来我们通过一个简单的实例演示上述这两种针对服务回收的编程方式之间的差异。我们在一个控制台应用中定义了一个继承自IDisposable的服务接口IFoobar和实现它的服务类Foobar。如下面的代码片段所示，为了确认对象真正被GC回收的时机，我们为Foobar定义了一个析构函数。在该析构函数和Dispose方法中，我们还会在控制台上输出相应的指导性文字。 public interface IFoobar: IDisposable {} public class Foobar : IFoobar { ~Foobar() { Console.WriteLine(\"Foobar.Finalize()\"); } public void Dispose() { Console.WriteLine(\"Foobar.Dispose()\"); } } 在作为程序入口的Main方法中，我们创建了一个ServiceCollection对象并采用Transient模式将IFoobbar/Foobar注册其中。借助于通过该ServiceCollection创建的ServiceProvider，我们分别采用上述的两种方式获取服务实例并试图对它实施回收。为了强制GC实时垃圾回收，我们显式调用了GC的Collect方法。 class Program { static void Main(string[] args) { IServiceProvider serviceProvider = new ServiceCollection() .AddTransient() .BuildServiceProvider(); serviceProvider.GetService().Dispose(); GC.Collect(); Console.WriteLine(\"----------------\"); using (IServiceScope serviceScope = serviceProvider.GetService().CreateScope()) { serviceScope.ServiceProvider.GetService(); } GC.Collect(); Console.Read(); } } 该程序执行之后会在控制台上产生如下所示的输出结果。从这个结果我们可以看出，如果我们使用现有的ServiceProvider来提供所需的服务实例，后者在GC进行垃圾回收之前并不会从内存中释放。如果我们利用现有的ServiceProvider创建一个ServiceScope，并利用它所在的ServiceProvider来提供我们所需的服务实例，GC是可以将其从内存中释放出来的。 Foobar.Dispose() ---------------- Foobar.Dispose() Foobar.Finalize() 4. Asp.Net Core 服务生命周期 DI框架所谓的服务范围在ASP.NET Core应用中具有明确的边界，指的是针对每个HTTP请求的上下文，也就是服务范围的生命周期与每个请求上下文绑定在一起。如图6所示，ASP.NET Core应用中用于提供服务实例的IServiceProvider对象分为两种类型，一种是作为根容器并与应用具有相同生命周期的IServiceProvider，另一个类则是根据请求及时创建和释放的IServiceProvider，我们可以将它们分别称为Application ServiceProvider和Request ServiceProvider。 在ASP.NET Core应用初始化过程中，即请求管道构建过程中使用的服务实例都是由Application ServiceProvider提供的。在具体处理每个请求时，ASP.NET Core框架会利用注册的一个中间件来针对当前请求创建一个服务范围，该服务范围提供的Request ServiceProvider用来提供当前请求处理过程中所需的服务实例。一旦服务请求处理完成，上述的这个中间件会主动释放掉由它创建的服务范围。 5. ASP.NET Core 服务范围检验 如果我们在一个ASP.NET Core应用中将一个服务的生命周期注册为Scoped，实际上是希望服务实例采用基于请求的生命周期。 假定以下场景。 在一个ASP.NET Core应用中采用Entity Framework Core来访问数据库，我们一般会将对应的DbContext类型（姑且命名为FoobarDbContext）注册为一个Scoped服务，这样既可以保证在FoobarDbContext能够在同一个请求上下文中被重用，也可以确保FoobarDbContext在请求结束之后能够及时将数据库链接释放掉。 假定有另一个Singleton服务（姑且命名为Foobar）具有针对FoobarDbContext的依赖。由于Foobar是一个Singleton服务实例，所以被它引用的FoobarDbContext也只能在应用关闭的时候才能被释放。 为了解决以上这个问题，可以让IServiceProvider在提供Scoped服务实例的时候进行针对性的检验。针对服务范围验证的开关由ServiceProviderOptions的ValidateScopes属性来控制，默认情况下是关闭的。如果希望开启针对服务范围的验证，我们可以在调用IServiceCollection接口的BuildServiceProvider方法的时候指定一个ServiceProviderOptions对象作为参数，或者直接调用另一个扩展方法并将传入的参数validateScopes设置为True。 public class ServiceProviderOptions { public bool ValidateScopes { get; set; } } public static class ServiceCollectionContainerBuilderExtensions { public static ServiceProvider BuildServiceProvider(this IServiceCollection services, ServiceProviderOptions options); public static ServiceProvider BuildServiceProvider(this IServiceCollection services, bool validateScopes); } 针对服务范围的验证对于IServiceProvider来说是一项额外附加的操作，会对性能带来或多或少的影响，所以一般情况下这个开关只会在开发（Development）环境被开启，对于产品（Production）或者预发（Staging）环境下最好将其关闭。 [1] 对于分别采用 Scoped和Singleton模式提供的服务实例，当前ServiceProvider和根ServiceProvider分别具有对它们的引用。如果采用Transient模式，只有服务类型实现了IDisposable接口，当前ServiceProvider才需要对它保持引用以完成对它们的回收，否则没有任何一个ServiceProvider保持对它们的引用。 参考文献 http://www.cnblogs.com/artech/p/asp-net-core-di-life-time.html https://www.cnblogs.com/artech/p/net-core-di-08.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-aspnetcore.html":{"url":"pages/di-aspnetcore.html","title":"3.8 Asp.Net Core DI 使用","keywords":"","body":"Asp.Net Core 依赖注入使用 1. 依赖注入在管道构建过程中的使用 2. 依赖服务注册 3. 依赖服务消费 3.1 Controller/PageModel 3.2 View 3.3 HttpContext获取实例 1. 依赖注入在管道构建过程中的使用 在ASP.NET Core管道的构架过程中主要涉及三个对象/类型，作为宿主的WebHost和它的创建者WebHostBuilder，以及注册到WebHostBuilder的Startup类型。 如下的代码片段体现了启动ASP.NET Core应用采用的典型编程模式：我们首先创建一个IWebHostBuilder对象，并将Startup类型注册到它之上。在调用Build方法创建WebHost之前，我们还可以调用相应的方式做其他所需的注册工作。当我们调用WebHost的Run方法之后，后者会利用注册的Startup类型来构建完整的管道。那么在管道的构建过程中，DI是如何被应用的呢？ WebHost.CreateDefaultBuilder(args) .UseStartup() .Xxx .Build() .Run(); DI在ASP.NET Core管道构建过程中的应用基本体现在下面这个序列图中。当我们调用WebHostBuilder的Build方法创建对应的WebHost的时候，前者会创建一个ServiceCollection对象，并将一系列预定义的服务注册在它之上。接下来WebHostBuilder会利用这个ServiceCollection对象创建出对应的ServiceProvider，这个ServiceProvider和ServiceCollection对象会一并传递给最终创建WebHost对象。当我们调用WebHost的Run方法启动它的时候，如果注册的Startup是一个实例类型，则会以构造器注入的方式创建对应的Startup对象。我们注册的Startup类型的构造函数是允许定义参数的，但是参数类型必须是预先注册到ServiceCollection中的服务类型。 注册的Startup方法可以包含一个可选的ConfigureServices方法，这个方法具有一个类型为IServiceCollection接口的参数。WebHost会将WebHostBuilder传递给它的ServiceCollection作为参数调用这个ConfigureServices方法，而我们则利用这个方法将注册的中间件和应用所需的服务注册到这个ServiceCollection对象上。在这之后，所有需要的服务（包括框架和应用注册的服务）都注册到这个ServiceCollection上面，WebHost会利用它创建一个新的ServiceProvider。WebHost会利用这个ServiceProvider对象以方法注入的方式调用Startup对象/类型的Configure方法，最终完成你对整个管道的建立。换句话会说，定义在Startup类型中旨在用于注册Middleware的Configure方法除了采用IApplicationBuilder作为第一个参数之外，它依然可以采用注册的任何一个服务类型作为后续参数的类型。 服务的注册除了现在注册的Startup类型的ConfigureServices方法之外，实际上还具有另一个实现方式，那就是调用IWebHostBuilder定义的ConfigureServices方法。当WebHostBuilder创建出ServiceCollection对象并完成了默认服务的注册后，我们通过调用这个方法所传入的所有Action对象将最终应用到这个ServiceCollection对象上。 public interface IWebHostBuilder { IWebHostBuilder ConfigureServiecs(Action configureServices); } 值得一提的是，Startup类型的ConfigureServices方法是允许具有一个IServiceProvider类型的返回值，如果这个方法返回一个具体的ServiceProrivder，那么WebHost将不会利用ServiceCollection来创建ServiceProvider，而是直接使用这个返回的ServiceProvider来调用Startup对象/类型的Configure方法。这实际上是一个很有用的扩展点，使用它可以实现针对第三方DI框架（如Unity、Castle、Ninject和AutoFac等）的集成。 这里我们只是简单的介绍了Asp.Net Core程序启动的简单过程，具体实现细节属于Asp.Net Core框架的内容，我们将在后续Asp.Net Core 程序启动源码和DI源码分析中做详细介绍 2. 依赖服务注册 接下来我们通过一个实例来演示如何利用Startup类型的ConfigureServices来注册服务，以及在Startup类型上的两种依赖注入形式。如下面的代码片段所示，我们定义了两个服务接口（IFoo和IBar）和对应的实现类型（Foo和Bar）。其中服务Foo是通过调用WebHostBuilder的ConfigureServices方法进行注册的，而另一个服务Bar的注册则发生在Startup的ConfigureServices方法上。对于Startup来说，它具有一个类型为IFoo的只读属性，该属性在构造函数利用传入的参数进行初始化，不用说这体现了针对Startup的构造器注入。Startup的Configure方法除了ApplicationBuilder作为第一个参数之外，还具有另一个类型为IBar的参数，我们利用它来演示方法注入。 public interface IFoo { } public interface IBar { } public class Foo : IFoo { } public class Bar : IBar { } public class Program { public static void Main(string[] args) { WebHost.CreateDefaultBuilder(args) .ConfigureServices(services => services.AddSingleton()) .UseStartup() .Build() .Run(); } } public class Startup { public IFoo Foo { get; private set; } public Startup(IFoo foo) { this.Foo = foo; } public void ConfigureServices(IServiceCollection services) { // 最常用的服务注册方式 services.AddTransient(); } public void Configure(IApplicationBuilder app, IBar bar) { app.Run(async context => { context.Response.ContentType = \"text/html\"; await context.Response.WriteAsync($\"IFoo=>{this.Foo}\"); await context.Response.WriteAsync($\"IBar=>{bar}\"); }); } } 在Startup的Configure方法中，我们调用IApplicationBulder的Run方法注册了一个Middleware，后者将两个注入的服务的类型作为响应的内容输出。 另外，WebHostBuilder在创建ServiceCollection之后，会注册一些默认的服务（如IHostingEnvironment，ILoggerFactory等）。这些服务和我们自行注册的服务并没有任何区别，只要我们知道对应的服务类型，就可以通过注入的方式获取并使用它们。 ASP.NET Core的一些组件已经提供了一些实例的绑定，像AddMvc就是Mvc Middleware在 IServiceCollection上添加的扩展方法。 public static IMvcBuilder AddMvc(this IServiceCollection services) { if (services == null) { throw new ArgumentNullException(nameof(services)); } var builder = services.AddMvcCore(); builder.AddApiExplorer(); builder.AddAuthorization(); AddDefaultFrameworkParts(builder.PartManager); ... } 3. 依赖服务消费 依赖服务之后就可以在需要的位置消费服务了。DI的三种注入方式，Asp.Net Core默认仅支持构造器注入方式和面向约定的方法注入(框架级别使用，如Starup的Config方法)。上面案例中在Startup的构造函数和Config方法分别体现了两种注入方式。 下面我们来演示在Asp.Net Core项目中Startup之外的位置如何消费DI服务。 3.1 Controller/PageModel private ILoginService _loginService; public AccountController( ILoginService loginService) { _loginService = loginService; } 我们只要在控制器的构造函数里面写了这个参数，ServiceProvider就会帮我们注入进来。 3.2 View 在View中需要用@inject 再声明一下，起一个别名。 @using MilkStone.Services; @model MilkStone.Models.AccountViewModel.LoginViewModel @inject ILoginService loginService @loginService.GetUserName() 3.3 HttpContext获取实例 HttpContext下有一个RequestedService同样可以用来获取实例对象，不过这种方法一般不推荐。同时要注意GetService<>这是个范型方法，默认如果没有添加Microsoft.Extension.DependencyInjection的using，是不用调用这个方法的。 HttpContext.RequestServices.GetService>(); 参考文献 https://www.cnblogs.com/artech/p/dependency-injection-in-asp-net-core.html https://www.cnblogs.com/jesse2013/p/di-in-aspnetcore.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/di-src.html":{"url":"pages/di-src.html","title":"3.9 Asp.Net Core DI 源码分析","keywords":"","body":"Asp.Net Core 依赖注入源码分析 1. 程序启动DI源码解析 2. 配置文件DI 2.1 配置文件DI基本使用 2.2 配置文件DI源码解析 1. 程序启动DI源码解析 在Asp.Net Core 依赖注入使用之“依赖注入在管道构建过程中的使用”中我们简单的介绍了DI在程序启动中的使用过程，接下来让我们从Asp.Net Core源码角度来深入探讨这一过程。 以下分析源码分析基于Asp.Net Core 2.1 https://github.com/aspnet/AspNetCore/tree/release/2.1 1) 定位程序入口 public static void Main(string[] args) { CreateWebHostBuilder(args) .Build() .Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) => WebHost.CreateDefaultBuilder(args) .UseStartup(); 可以看到asp.net core程序实际上是一个控制台程序，运行一个Webhost对象从而启动一个一直运行的监听http请求的任务。 2) 定位IWebHostBuilder实现，路径为src/Hosting/Hosting/src/WebHostBuilder.cs 1) 通过上面的代码我们可以看到首先是通过BuildCommonServices来构建一个ServiceCollection。为什么说这么说呢，先让我们我们跳转到BuidCommonServices方法中看下吧。 通过var services = new ServiceCollection();创建了一个ServiceCollection然后往services里面注入很多内容，如：WebHostOptions ，IHostingEnvironment ，IHttpContextFactory ，IMiddlewareFactory等。最后这个BuildCommonServices就返回了这个services对象。 4）UseStartup()。 在上面的BuildCommonServices方法中也有对IStartup的注入。首先，判断Startup类是否继承于IStartup接口，如果是继承的，那么就可以直接加入在services 里面去，如果不是继承的话，就需要通过ConventionBasedStartup(methods)把method转换成IStartUp后注入到services里面去。结合上面我们的代码，貌似我们平时用的时候注入的方式都是采用后者。 5）回到build方法拿到了BuildCommonServices方法构建的ServiceCollection实例后，通过GetProviderFromFactory(hostingServices) 方法构造出了IServiceProvider 对象。到目前为止，IServiceCollection和IServiceProvider都拿到了。然后根据IServiceCollection和IServiceProvider对象构建WebHost对象。构造了WebHost实例还不能直接返回，还需要通过Initialize对WebHost实例进行初始化操作。那我们看看在初始化函数Initialize中，都做了什么事情吧。 1) 找到src/Hosting/Hosting/src/Internal/WebHost.cs的Initialize方法。如下图所示：主要就是一个EnsureApplicationServices方法。 1) EnsureApplicationServices内容如下：拿到Startup 对象，然后把_applicationServiceCollection 中的对象注入进去。 1) 至此build中注册的对象以及StartUp中注册的对象都已经加入到依赖注入容器中了，接下来就是Run起来了。这个run的代码在src\\Hosting\\Hosting\\src\\WebHostExtensions.cs中，代码如下： WebHost执行RunAsync运行web应用程序并返回一个只有在触发或关闭令牌时才完成的任务。这就是我们运行ASP.Net Core程序的时候，看到的那个命令行窗口了，如果不关闭窗口或者按Ctrl+C的话是无法结束的。 2. 配置文件DI 除了Asp.Net Core 依赖注入使用中提到的服务注册方式。我们还可以通过配置文件进行对象注入。需要注意的是通过读取配置文件注入的对象采用的是Singleton方式。 2.1 配置文件DI基本使用 1）在appsettings.json里面加入如下内容 { \"Logging\": { \"LogLevel\": { \"Default\": \"Warning\" } }, \"Author\": { \"Name\":\"Colin\", \"Nationality\":\"China\" } } 2) Startup类中ConfigureServices中注册TOptions对象 services.Configure(Configuration.GetSection(\"Author\"));//注册TOption实例对象 3）消费配置的服务对象,以Controller为例 private readonly Author author; public TestController(IOptions option) { author = option.Value; } 2.2 配置文件DI源码解析 1）在Main方法默认调用了WebHost.CreateDefaultBuilder方法创建了一个IWebHost对象，此方法加载了配置文件并使用一些默认的设置。 public static void Main(string[] args) { CreateWebHostBuilder(args) .Build() .Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) => WebHost.CreateDefaultBuilder(args) .UseStartup(); 2）在src\\MetaPackages\\src\\Microsoft.AspNetCore\\WebHost.cs 中查看CreateDefaultBuilder方法源码如下。可以看到这个方法会在ConfigureAppConfiguration 的时候默认加载appsetting文件，并做一些初始的设置，所以我们不需要任何操作，就能加载appsettings 的内容了。 1) Asp.Net Core的配置文件是支持热更新的，即不重启网站也能加载更新。如上图所示只需要在AddJsonFile方法中设置属性reloadOnChange:true即可。 参考文献：https://www.cnblogs.com/yilezhu/p/9998021.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/pipeline-diagram.html":{"url":"pages/pipeline-diagram.html","title":"4.1 管道模型","keywords":"","body":" .pipeline{ width:3972px; height:2400px; border:0; overflow:scroll; } © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/pipeline-middlewire.html":{"url":"pages/pipeline-middlewire.html","title":"4.2 中间件","keywords":"","body":"中间件 待整理... 1. 简介 2. 工作原理与过程 3. 常用Middlewire 4. 自定义Middlewire © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/pipeline-lifetime.html":{"url":"pages/pipeline-lifetime.html","title":"4.3 生命周期","keywords":"","body":"生命周期 在管道模型中我们了解到了Asp.Net Core如何处理一个Http请求的过程及其管道构建过程。这一节我们将对声明周期中的诸多细节做一些简单讲解和补充。 1.IApplicationLifetime 在传统Asp.Net MVC中我们可以在Global的Application_Start等管道事件中做某些业务处理，Asp.Net Core的管道模型已经发生了变化，但IApplicationLifetime服务允许我们响应ApplicationStarted,ApplicationStopping,ApplicationStopped三个事件。 public void Configure(IApplicationBuilder app, IHostingEnvironment env,IApplicationLifetime lifetime) { lifetime.ApplicationStarted.Register(() => { Console.WriteLine(\"程序启动完成\"); }); lifetime.ApplicationStopped.Register(() => { Console.WriteLine(\"程序已停止\"); }); //do something else ... } © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/pipeline-environment.html":{"url":"pages/pipeline-environment.html","title":"4.4 环境变量","keywords":"","body":"ASP.NET Core 环境变量 1. 环境变量简介 2. 设置环境变量 2.1 UseEnvironment 2.2 launchSettings.json 3. 使用环境变量 3.1 前端 3.2 后端 1. 环境变量简介 Asp.Net Core的环境变量和启动设置，将开发过程中的调试和测试变的更加简单。我们只需要简单的修改配置文件，就可以实现开发、预演、生产环境的切换。 ASP.NET Core控制环境切换依赖于“ASPNETCORE_ENVIRONMENT”环境变量。此环境变量框架默认提供了三个值，当然我们也可以定义其它的值： Development（开发） Staging（预演） Production（生产） 2. 设置环境变量 2.1 UseEnvironment 我们可以使用IWebHostBuilder的UseEnvironment方法来设定ASPNETCORE_ENVIRONMENT变量值。 WebHost.CreateDefaultBuilder(args) .UseEnvironment(EnvironmentName.Production) //设置ASPNETCORE_ENVIRONMENT .UseStartup(); 2.2 launchSettings.json ASP.Net Core包含一个launchSettings.json的文件,此文件是项目启动配置文件。我们可在其中配置ASPNETCORE_ENVIRONMENT环境变量。 3. 使用环境变量 环境变量检测在WebHost构建过程中注册为了IHostingEnvironment服务， 该类型的变量表示的是当前应用程序运行的环境，ASP.Net Core提供了四个扩展方法，用于检测 “ASPNETCORE_ENVIRONMENT”当前的值。 IsDevelopment() //是否为开发环境 IsStaging() //是否为预演环境 IsProduction() //是否为生产环境 IsEnvironment(string environmentname) //是否为某种环境 3.1 前端 在Asp.Net Core视图中我们可以通过environment标签来使用环境变量。 3.2 后端 我们可以在任何需要根据环境控制应用程序行为的地方注入并使用IHostingEnvironment。比如默认的Startup的Config方法中根据是否为开发环境显示不同的错误展示方式。 public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(\"/Home/Error\"); // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts. app.UseHsts(); } // do something else ... } IHostingEnvironment 常用成员 除了读取环境变量，IHostingEnvironment还有以下常用成员。 属性 含义 ApplicationName 当前程序名称 ContentRootPath 网站根目录(绝对路径) WebRootPath 网站wwwroot目录(绝对路径) 参考文档：https://www.cnblogs.com/tdfblog/p/Environments-LaunchSettings-in-Asp-Net-Core.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/supplement.html":{"url":"pages/supplement.html","title":"5. Session和Cache","keywords":"","body":"缓存、Session 1. 缓存 Asp.Net Core不再支持HttpContext.Cache,转而使用MemoryCache,这是一种服务端内存缓存。使用方式方式非常简单，在Startup的ConfigureServices方法中注册服务，需要使用的位置注入IMemoryCache对象即可。 除了内存缓存，我们还可以使用Redis等分布式缓存 2. Session 在Asp.Net Core中使用Session需要首先添加对Session的支持,否则会报错Session has not been configured for this application or request。 Session使用步骤： 1) 注册服务。ConfigureServices中services.AddSession(); 2) 注册中间件。Configure中app.UseSession(); 3）使用Session HttpContext.Session.SetString(\"userName\",\"Colin\"); string userName = HttpContext.Session.GetString(\"userName\") 目前Session默认仅支持存储int、string和byte[]类型，其他复杂类型可以使用json序列化后存储字符串。 TempData也依赖于 Session,所以也要配置 Session。 默认Session为服务器端进程内存储，我们也可以使用Redis做进程外Session。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/auth-authentication.html":{"url":"pages/auth-authentication.html","title":"6.1 Authentication","keywords":"","body":"身份认证 https://www.cnblogs.com/RainingNight/p/introduce-basic-authentication-in-asp-net-core.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/auth-cookie.html":{"url":"pages/auth-cookie.html","title":"6.2 Cookie Authentication","keywords":"","body":"Cookie-based 认证授权 这里我们只介绍Asp.Net Core中基于Cookie的认证授权使用方式。其认证授权原理参见Session认证。 Cookie-base认证授权方式多用于Web项目。前后端分离的Web项目含App的多端项目一般多使用JWT认证。 1. 配置 Authentication \b在Startup中注册认证服务，添加认证中间件。 public void ConfigureServices(IServiceCollection services) { //注册认证服务 services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme).AddCookie(); services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { //添加认证中间件 app.UseAuthentication(); app.UseMvc(); } 2. 登录注销 public class AccountController : Controller { public async Task Login(string userName, string password, string returnUrl) { if (userName != \"admin\" || password != \"123\") return Content(\"用户名或密码错误\"); var claims = new List { new Claim(ClaimTypes.Name, userName), new Claim(ClaimTypes.Role, \"admin\")//设置角色 }; await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, new ClaimsPrincipal(new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme))); if (!string.IsNullOrWhiteSpace(returnUrl)) return Redirect(returnUrl); return Ok(\"登录成功\"); } public async Task Logout() { await HttpContext.SignOutAsync(); return Ok(\"注销成功\"); } } 3. 使用认证授权 [Authorize(Roles = \"admin\")]//基于基色验证身份 public class HomeController : Controller { public IActionResult Index() { return View(); } } 在需要认证授权的Controller或Action打上Authorize标记即可启用认证。认证不通过默认会导航到/Account/Login,授权不通过默认会导航到/Account/AccessDenied，也可以在注册服务时修改默认配置。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/auth-jwt.html":{"url":"pages/auth-jwt.html","title":"6.3 JwtBear Authentication","keywords":"","body":"JWT 认证授权 这里我们只介绍Asp.Net Core中基于JWT的认证授权使用方式。其认证授权原理参见JWT原理。 1. 配置 Authentication 1.1 Jwt配置 配置文件。 { \"AllowedHosts\": \"*\", \"JwtSettings\": { \"Issuer\": \"http://localhost:5000\", \"Audience\": \"http://localhost:5000\", \"SecretKey\": \"your_custom_secret_key_more_than_16_bytes\" } } Issuer和Audience分别代表JWT颁发者和接收方，非必须项。SecretKey长度至少为128 bits(16 bytes)。 添加配置项对应实体类。 public class JwtSettings { public string Issuer { get; set; } public string Audience { get; set; } public string SecretKey { get; set; } } 1.2 Startup配置 \b在Startup中注册认证服务，添加认证中间件。 public void ConfigureServices(IServiceCollection services) { //注册JWT配置 services.Configure(Configuration.GetSection(nameof(JwtSettings))); //读取JWT配置 var jwtSettings = new JwtSettings(); Configuration.Bind(nameof(jwtSettings), jwtSettings); //注册认证服务 services.AddAuthentication(options => { options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(options => { options.TokenValidationParameters = new TokenValidationParameters { ValidIssuer = jwtSettings.Issuer, ValidAudience = jwtSettings.Audience, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings.SecretKey)) }; }); //注册授权服务 services.AddAuthorization(options => options.AddPolicy(\"sa\", policy => policy.RequireClaim(\"SuperAdmin\")));//添加一个名为 \"sa\"的Policy，要求必须存在\"SuperAdmin\"的Claim services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { //添加认证中间件 app.UseAuthentication(); app.UseMvc(); } 2. 申请认证 [Route(\"api/authorize\")] [ApiController] public class AuthorizeController : ControllerBase { private JwtSettings _jwtSettings; public AuthorizeController(IOptions jwtSettings) { _jwtSettings = jwtSettings.Value; } [HttpPost] public ActionResult Post([FromBody] User user) { //登录验证 if (user.UserName != \"colin\" || user.Password != \"123\") return BadRequest(\"用户名或密码错误\"); //签发JWT var claims = new Claim[] { new Claim(ClaimTypes.Name, user.UserName), // new Claim(ClaimTypes.Role, \"admin\"),//授予admin角色 new Claim(\"SuperAdmin\", \"true\") //授予SuperAdmin Policy }; var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey)); var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256); var token = new JwtSecurityToken(_jwtSettings.Issuer, _jwtSettings.Audience, claims, DateTime.Now, DateTime.Now.AddMonths(1), credentials); var jwt = new JwtSecurityTokenHandler().WriteToken(token); return Ok(jwt); } } public class User { public string UserName { get; set; } public string Password { get; set; } } 3. 使用认证授权 [Authorize(\"sa\")]//基于Policy - \"sa\" 进行授权检查 [Route(\"api/values\")] [ApiController] public class ValuesController : ControllerBase { [HttpGet] public ActionResult> Get() { return new string[] {\"value1\", \"value2\"}; } } 标准的Bearer Token授权方式，在发送HTTP请求时会在Request.Header中添加Authorization项，内容是Bearer Token。如下图所示。 在需要认证授权的Controller或Action打上Authorize标记即可启用认证。现在更多推荐使用基于Policy的授权方式。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/auth-auth2.html":{"url":"pages/auth-auth2.html","title":"6.4 OAuth2 & OpenID Connect Authentication","keywords":"","body":"OAuth 2.0 & OpenID Connect 认证 https://www.cnblogs.com/RainingNight/p/oidc-authentication-in-asp-net-core.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/authorization.html":{"url":"pages/authorization.html","title":"6.5 Authorization","keywords":"","body":"授权 https://www.cnblogs.com/RainingNight/p/authorization-in-asp-net-core.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/webapi-restful.html":{"url":"pages/webapi-restful.html","title":"7.1 WebAPI和Restful","keywords":"","body":"WebAPI和Restful 本文中如果不做说明，本章所有内容均基于Asp.Net Core WebAPI (2.2)。 1. WebAPI WebAPI是一种用来开发系统间接口、设备接口API的技术,基于Http协议,请求和返回格式结果默认是json格式。比WCF更简单、更通用,比 WebService更节省流量、更简洁。 普通ASP.Net MVC甚至HttpHandler也可以开发API,但 WebAPI是更加专注于此的技术，更专业。 Asp.Net WebAPI和Asp.Net MVC有着非常密切的联系，WebAPI中可以复用MVC的路由、ModelBinder、Filter 等知识,但是只是相仿, 类名、命名空间等一般都不一样,用法也有一些差别。 Asp.Net WebAPI 具有以下特点： Action方法更专注于数据处理 更适合于Restful风格 不依赖于Web服务器,可以selfhost,或者寄宿于控制台或服务程序等 没有界面。WebAPI是接口开发技术,普通用户不会直接和WebAPI打交道 2. Restful Http设计之初是有 “谓词语义” 的。这里谓词是指HttpMethod,常用的包括Get、Post、Put、Delete 等。 通常情况下，使用Get获取数据，使用Post新增数据，使用Put修改数据，使用Delete删除数据。使用Http状态码表示处理结果。如 找不到资源使用404，没有权限使用401。此设计倾向于把所有业务操作抽象成对资源的CRUD操作。 如果API设计符合Http谓词语义规则，那么就可以称其符合Restful风格。Asp.Net WebAPI 设计之初就符合Restful风格。 Restful风格设计具有以下优势： 方便按类型操作做权限控制，如设置Delete权限只需处理Delete请求方式即可。 不需要复杂的Action方法名，转而根据HttpMethod匹配请求 充分利用Http状态码,不需要另做约定 浏览器可以自动缓存Get请求,有利于系统优化 Restful风格设计同时也有许多弊端。仅通过谓词语义和参数匹配请求理论性太强，许多业务很难完全拆分为CRUD操作，如用户登录同时更新最后登录时间。另外，Http状态码有限，在很多业务场景中不足以表述处理结果，如“密码错误”和“AppKey错误”。 由于以上问题，导致Restful设计在很多业务场景中使用不便，很多大公司API也鲜少都能满足Restful规范。因此我们的原则是，尽可能遵守Restful规范，灵活变通，不追求极端。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/webapi-basic.html":{"url":"pages/webapi-basic.html","title":"7.2 WebAPI基础","keywords":"","body":"WebAPI 基础 WebAPI 基础 1. ApiController 2. 路由匹配 2.1 RouteAttribute 和 HttpMethodAttribute 2.2 Restful 路由 2.3 自定义路由 2.3.1 Restful 之殇 2.3.2 自定义Action路由 2.3.3 回归MVC路由 3. API参数 3.1 URL参数 3.2 对象参数 4. 返回值 5. 异常处理 5.1 \b业务性错误 5.2 常规异常处理 5.3 \b全局异常过滤器 1. ApiController WebAPI中Controller直接即继承自ControllerBase。在ASP.NET Core 2.1之后引入[ApiController]用于批注 Web API 控制器类。[ApiController]特性通常结合ControllerBase来为控制器启用特定 REST 行为。 [Route(\"api/[controller]\")] [ApiController] public class ProductsController : ControllerBase 在 ASP.NET Core 2.2 或更高版本中，可将[ApiController]特性应用于程序集。以这种方式进行注释，会将 web API 行为应用到程序集中的所有控制器。 建议将程序集级别的特性应用于 Startup 类。 [assembly: ApiController] namespace WebApiSample.Api._22 { public class Startup { } 2. 路由匹配 2.1 RouteAttribute 和 HttpMethodAttribute WebAPI中必须为每个Controller使用[Route]特性进行路由设定，而不能通过UseMvc中定义的传统路由或通过Startup.Configure中的UseMvcWithDefaultRoute配置路由。 与Controller设定路由方式一样，我们也可以在Action方法上使用[Route]单独设定路由，除了[Route]，我们也可以使用HttpMethodAttribute设定路由，用法相同，HttpMethodAttribute包括[HttpGet]、[HttpPost]、[HttpPut]、[HttpDelete]等。Action路由建立在Controller路由之上。 使用HttpMethodAttribute定义路由时会同时限制Action方法的HTTP访问方式，如果单纯想为Action方法设定路由同时允许多种HTTP访问方式，可以是使用[Route]配置路由。 路由不区分大小写。 [Route(\"api/test\")] public class TestController : ControllerBase { // GET api/test [HttpGet] public ActionResult Get() { return nameof(Get); } //GET api/test/1 [HttpGet(\"{id}\")] public ActionResult Get(int id) { return nameof(Get) + id; } //GET api/test/getbyname/colin [HttpGet(\"GetByName/{name?}\")] public ActionResult Get(string name) { return \"GetByName\" + name; } //GET api/test/colin/18 [HttpGet(\"{name}/{age}\")] public ActionResult Get(string name,int age) { return nameof(Get) + name + age; } } 2.2 Restful 路由 WebAPI默认路由使用Restful风格,按照请求方式进行路由，不作标记的情况下，Action方法名会按照请求方式进行StartWith匹配。所以的Get()、GetById()、GetXXX()没有任何区别。如果使用[HttpGet]标记了Action方法，则方法名任意取，不必以GET开头。同理，POST、PUT、DELETE亦是如此。 2.3 自定义路由 2.3.1 Restful 之殇 完全符合Restful风格的API在很多业务常见下并不能满足需求。如之前所说，把所有业务抽象为CRUD操作并不现实，简单通过HTTP状态码也不容易区分处理结果。除此之外，仅通过简单几种谓词语意进行路由在难以满足复杂业务需求。如，根据ID查询用户、根据用户名查询用户、根据手机号查询用户。 // 错误方式，调用报错 [Route(\"api/test\")] public class TestController : ControllerBase { [HttpGet(\"{id}\")] public ActionResult GetById(int id) { return Users.FirstOrDefault(u=>u.Id==id); } [HttpGet(\"{userName}\")] public ActionResult GetByUserName(string userName) { return Users.FirstOrDefault(u=>u.UserName==userName); } [HttpGet(\"{phoneNumber}\")] public ActionResult GetByPhoneNumber(string phoneNumber) { return Users.FirstOrDefault(u=>u.PhoneNumber==phoneNumber); } } 以上代码可以编译通过，但由于三个Action匹配相同路由规则，所以GET请求~/api/test/xxx 时会出现歧义而抛出AmbiguousMatchException。 2.3.2 自定义Action路由 此时我们可以通过前面提到的RouteAttribute或HttpMethodAttribute来为每个Action设置特定路由。 // 自定义Action路由 [Route(\"api/test\")] public class TestController : ControllerBase { //GET api/test/getbyid/1 [HttpGet(\"GetById/{id}\")] public ActionResult GetById(int id) { return Users.FirstOrDefault(u=>u.Id==id); } //GET api/test/getbyusername/colin [HttpGet(\"GetByUserName/{userName}\")] public ActionResult GetByUserName(string userName) { return Users.FirstOrDefault(u=>u.UserName==userName); } //GET api/test/getbyphonenumber/110 [HttpGet(\"GetByPhoneNumber/{phoneNumber}\")] public ActionResult GetByPhoneNumber(string phoneNumber) { return Users.FirstOrDefault(u=>u.PhoneNumber==phoneNumber); } } 2.3.3 回归MVC路由 以上为每个Action单独配置路由后解决了Restful遇到的问题。不难发现当每个Action方法路由名称恰好是自身方法名时，我们便可以通过Action名称来访问对应接口，这与MVC路由方式效果一致。 单独为每个Action方法都配置路由较为繁琐，我们可以仿照MVC路由方式直接配置Controller路由，路由效果一致，但使用跟简单。 // 自定义Controller路由 [Route(\"api/test/{Action}\")] public class TestController : ControllerBase { //GET api/test/getbyid/1 [HttpGet(\"{id?}\")] public ActionResult GetById(int id) { return Users.FirstOrDefault(u=>u.Id==id); } //GET/POST/PUT/DELETE api/test/getbyusername/colin [Route(\"{userName}\")] public ActionResult GetByUserName(string userName) { return Users.FirstOrDefault(u=>u.UserName==userName); } //GET api/test/getbyphonenumber?phoneNumber=110 [HttpGet] public ActionResult GetByPhoneNumber(string phoneNumber) { return Users.FirstOrDefault(u=>u.PhoneNumber==phoneNumber); } } Restful风格路由与MVC路由只是匹配Action方法方式不同，MVC路由通过Action方法名定位要比Restful通过谓词语意定位更加多变，更容易应付复杂的业务场景。 3. API参数 GET、POST、PUT、DELETE等所有请求方式均可使用 URL参数 和 对象参数 进行参数传递。 GET和DELETE请求通常传递数据量较少，多使用URL参数。POST和PUT请求通常传递数量较大，多使用对象参数。 3.1 URL参数 简单参数有两种，QueryString参数和路由参数，这两种都参数以不同形式体现在URL中，所以我们统称为URL参数。 在参数少且简单对安全性要求不高的情况下，可以使用URL参数。 [Route(\"api/test\")] public class TestController : ControllerBase { //GET api/test?name=colin&age=18 [HttpGet] public ActionResult Get(string name, int age) { return name + age; } //DELETE api/test/1 [HttpDelete(\"{id}\")] public ActionResult Delete(int id) { return NoContent(); } } 3.2 对象参数 参数内容多且复杂或安全性较高的情况下，在API中接收参数时我们常把参数字段封装到一个参数模型类中。使用非URL参数而不在服务端封装对象会遇到很多麻烦，不建议使用。 客户端传递对象参数的方式有很多中，一般需要约定Content-Type报文头。服务端接收对象参数常使用[FromXXX]特性。 特性 ContentType 传参方式 [FromQuery] - ?name=colin&age=18 [FromHeader] - 或 application/x-www-form-urlencoded 或 multipart/form-data ?name=colin&age=18 或 key-value对 [FromForm] multipart/form-data 或 application/x-www-form-urlencoded name-value对 [FromBody] 或 无标记 application/json {name:'colin',age:18} [Route(\"api/test\")] public class TestController : ControllerBase { [HttpPost] public ActionResult Post([FromForm] Person p) { return CreatedAtAction(nameof(Post), new {id = p.Id}, p); } [HttpPut(\"{id}\")] public ActionResult Put(int id, [FromBody] Person p) { return NoContent(); } JSON ContentType为applciation/json时，传递参数必须是JSON格式。 按照JSON官网的规范（\"A value can be a string in double quotes, or a number, or true or false or null, or an object or an array. These structures can be nested.\"），JSON可以直接传递字符串、数字和布尔三种简单类型。需要特别注意的是，字符串需要包裹在双引号直接(双引号作为字符串的一部分)。 [HttpPost] public void Post([FromBody] string value) { } 4. 返回值 ASP.NET Core 提供以下 Web API 控制器操作返回类型选项： 特定类型 IActionResult ActionResult 多数情况下返回数据时统一使用ActionResult类型。T是实际属数据类型，在Action方法中编码时直接返回T类型数据即可。ASP.NET Core 自动将对象序列化为 JSON，并将 JSON 写入响应消息的正文中。 三种返回类型具体区别和使用参见官方文档。 5. 异常处理 5.1 \b业务性错误 简单的错误可以直接使用HttpStatusCode返回，如请求资源不能存在直接返回NotFound(404)即可。 较为复杂的业务错误,如，“用户年龄不合法”、“Id不存在等”，这种情况HttpStatusCode不足以满足业务需要， 一般我们可以自定义一个统一的返回对象来做详细说明。 public interface IApiResult{} public class ApiResult:IApiResult { /// /// 业务码。可自定义一套业务码标准 /// public int Code { get; set; } = 200; /// /// 消息。一般可用于传输错误消息 /// public string Message { get; set; } /// /// 数据内容。一般为实际请求数据，如Json /// public T Content { get; set; } public ApiResult(int code, string message, T content) { Code = code; Message = message; Content = content; } } 使用方式如下： [HttpGet(\"{age}\")] public ActionResult Get(int age) { if (age 60) { return new ApiResult(0,\"年龄超限\",null); } else { return new ApiResult(1,\"OK\",\"123\"); } } 5.2 常规异常处理 在API代码中做好必要的异常捕捉和处理，如用户请求参数合法性校验等。一般API中只做简单的数据采集校验，响应和格式化返回数据等工作，复杂的业务逻辑处理是业务逻辑层的工作，一般在BLL中做异常捕获和处理。 5.3 \b全局异常过滤器 全局未处理异常可以通过异常过滤器来进行捕捉处理。 自定义异常过滤器。 public class MyAsyncExceptionFilter : IAsyncExceptionFilter { private ILogger _logger; public MyAsyncExceptionFilter(ILogger logger) { _logger = logger; } public async Task OnExceptionAsync(ExceptionContext context) { context.ExceptionHandled = true; var msg = context.Exception.Message; _logger.LogError(msg); context.Result = new ObjectResult(new ApiResult(500, msg, null)) {StatusCode = 500}; await Task.CompletedTask; } } Startup中注册过滤器。 public void ConfigureServices(IServiceCollection services) { services.AddMvc(options => { options.Filters.Add(); }); } © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/webapi-multiversion.html":{"url":"pages/webapi-multiversion.html","title":"7.3 多版本管理","keywords":"","body":"WebAPI 多版本管理 1. 多版本API 如果我们为APP设计并提供API，当APP发布新本后可能早期APP没有内置升级机制，也可能有些用户不愿升级，造成多个版本的APP同时在运行。开发新版本App时,要给API增加新的功能或者修改以前接口的规范,这可能会造成旧版 App无法使用,因此在一定情况下会“保留旧接口的运行、新功能用新接口”,这样 就会存在多版本接口共存的问题。 2. 多版本管理 多版本管理常见技术实现方案有以下三种: 域名区分。不同版本用不同的域名。如 v1.api.xxx.com、v2.api.xxx.com、v3... 反代服务器转发。在url或报文头中携带版本信息,然后Nginx等反代服务器按照不同版本将请求转发到不同服务器。 路由匹配。多版本共处于同项目中,然后使用[Route]将请求路由到不同的Controller或Action中。 通过域名区分和Nginx转发来两种方式进行API多版本管理时，可以借助代码分支隔离多版本代码。旧版API做一个代码分支,除了进行 bug 修复外不再做改动;新接口代码继续演化升级。最后分别部署不同版本API服务，通过域名绑定或反代转发进行区分即可。推荐使用这两种方式。 通过路由匹配方式进行多版本管理在系统规模较小时可以在一定程度上节省资源配置消耗，但所有版本代码都共存在一个项目中，不易维护且不利于后期系统拓展。 前两种方式都是在运维阶段配置完成，不再赘述。最后路由匹配的方式则需要在开发阶段完成，下面我们来分析一下最后一种方式。 1) ControllerRoute [Route(\"api/v1/test\")] public class TestV1Controller:ControllerBase { //GET api/v1/test/ [HttpGet] public ActionResult Get() { return \"v1-get\"; } } [Route(\"api/v2/test\")] public class TestV2Controller:ControllerBase { //GET api/v2/test/ [HttpGet] public ActionResult Get() { return \"v2-get\"; } } 2) ActionRoute [Route(\"api/test/{Action}\")] public class TestController : ControllerBase { //GET api/test/getv1 [HttpGet] public ActionResult GetV1() { return \"v1-get\"; } //GET api/test/getv2 [HttpGet] public ActionResult GetV2() { return \"v2-get\"; } } © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/webapi-security.html":{"url":"pages/webapi-security.html","title":"7.4 安全控制","keywords":"","body":"API 安全控制 1. 安全传输 2. 认证授权 2.1 Session 2.2 JWT 2.3 JWT 结构 2.4 JWT 操作 1. 安全传输 认证授权。对API做认证授权，每次请求接口需要携带认证信息，如JWT Token 请求重放。重复请求一个接口，如充值接口。要避免重复业务处理。每次请求的时候都带着当前时间(时间戳),服务器端比 较一下如果这个时间和当前时间相差超过一定时间,则失效。因此最多被重放一段时间, 这个要求客户端的时间和服务器端的时间要保持相差不大。有些业务场景下要使用一次性验证。 HTTPS。如果API暴露于外网建议使用HTTPS协议，可以增加被抓包难度。 2. 认证授权 认证授权是两个过程，简单说认证是告诉服务器你是谁，授权是服务器告诉你你可以做什么。关于服务端管理用户授权有很多的权限管理方式，这里我们就不做阐述了。这里我们主要看用户认证。 目前常用的认证方式有Session和JWT两种。 下面我们主要介绍两种认证方式的基本原理，两种认证默认都集成到Asp.Net Core中，具体使用方式，参见如下 Cookie-based 认证授权 JWT 认证授权 2.1 Session 前后端分离通过Restful API进行数据交互时，验证用户的登录信息及权限最传统的方式，前端提交用户名密码，后端验证通过后将用户信息记录到称为Session的内存区域中,Session是一个key-value集合，key一般名称为session_id唯一标识用户的一次会话，服务端会把session_id记录到Cookie中并返回给客户端，之后客户端每次请求都会带上这个session_id，服务端则可以根据session_id值来识别用户。 Session机制使用简单但也存在一些问题。 内存开销。每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言Session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。 扩展性。用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。但是可以使用Redis等进程外Session来解决。 安全性。如果我们的页面出现了XSS漏洞，由于 Cookie可以被JavaScript读取导致session_id泄露，而作为后端识别用户的标识，Cookie的泄露意味着用户信息不再安全。设置 httpOnly后Cookie将不能被 JS 读取，那么XSS注入的问题也基本不用担心了。浏览器会自动的把它加在请求的header当中，设置secure的话，Cookie就只允许通过HTTPS传输。secure选项可以过滤掉一些使用HTTP协议的XSS注入，但并不能完全阻止，二期还存在XSRF风险。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为Cookie默认被发了出去。 2.2 JWT JWT(JSON WEB TOKEN)是一个开放标准(RFC 7519)方法实现，用于通信双方之间安全认证。 前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。 服务端验证通过后将一些简单非敏感信息如UserId、UserRole等写到一个Json对象中并使用密钥签名后得到Token返回给客户端。 前端可以将返回的JWT Token保存在sessionStorage上，退出登录时前端删除保存的JWT即可。 前端每次请求将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) 后端验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。 验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。 优势： 跨语言支持 可以存储简单信息 易于扩展。不需要在服务端保存会话信息,易于应用扩展 SSO。认证信息存在客户端，子系统无需再进行认证 劣势： 不能强制客户端下线 不可存储敏感信息 Secret泄漏后不再安全 2.3 JWT 结构 如上图所示，JWT由Header、Payload、Signature三部分构成。 1） Header 属性 含义 alg 声明加密的算法 通常使用HMAC或SHA256 typ 声明类型，这里是JWT 2） Payload 这部分是我们存放信息的地方。 包含三个部分\"标准注册声明\"、\"公共声明\"、\"私有声明\"。 标准注册声明是固定名称，存放固定内容但不强制使用。 属性 含义 iss 签发者 sub 所面向的用户 aud 接收方 exp 过期时间，这个过期时间必须要大于签发时间 nbf 定义在什么时间之前，该jwt都是不可用的. iat 签发时间 jti 唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。私有声明是提供者和消费者所共同定义的声明。 3） Signature 这部分是防篡改签名。base64编码Header和Payload后使用.连接组成的字符串，然后通过Header中声明的加密方式进行加盐SecretKey组合加密，然后就构成了签名。 对头部以及负载内容进行签名，可以防止内容被窜改。虽然Header和Payload可以使用base64解码后得到明文，但由于不知道SecretKey所以客户端或任何第三方篡改内容后无法获得正确签名，服务端校验签名不正确便会得知认证内容被篡改了进而拒绝请求。 SecretKey保存在服务器端，用来进行JWT的签发和验证，务必确保其安全，一旦泄漏，任何人都可以自我签发JWT。 2.4 JWT 操作 public static string CreateJwt(Dictionary payload, string secret) { var builder = new JwtBuilder() .WithAlgorithm(new HMACSHA256Algorithm()) .WithSecret(secret); foreach (var key in payload.Keys) builder.AddClaim(key, payload[key]); return builder.Build(); } public static bool VerifyJwt(string token, string secret, out IDictionary payload) { try { payload = new JwtBuilder() .WithSecret(secret) .MustVerifySignature() .Decode>(token); return true; } catch (TokenExpiredException) { //JWT过期 payload = null; return false; } catch (SignatureVerificationException) { //签名错误 payload = null; return false; } } 基于 https://github.com/jwt-dotnet/jwt 参考文档： http://www.cnblogs.com/ldybyz/p/6943827.html https://www.jianshu.com/p/576dbf44b2ae https://lion1ou.win/2017/01/18/ © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/webapi-openapi.html":{"url":"pages/webapi-openapi.html","title":"7.5 OpenAPI","keywords":"","body":"OpenAPI OpenAPI 1. AppKey 2. OpenAPI 2.1 Swagger 1) Swagger 规范 2) Swagger UI 2.2 Swagger 集成 3. 开发SDK 1. AppKey 当我们将WebAPI对外网公开供所有开发者调用时，除了注意前面讲到安全控制之外，我们更常用AppKey来对开发者进行管理。 当一个开发者想基于我们开放的API开发一套第三方程序时，需要先到我们服务器申请一个AppKey，这枚AppKey即作为这个开发者的唯一身份标志，这个开发者开发的所有程序请求我们的API时都需要携带这枚AppKey。当我们发现某个开发者的程序有非法操作时，我们就可以在服务端禁用这枚AppKey，那此开发者的所有应用程序的请求API时都会被拒绝，但普通用户使用其他开发者的应用并不受影响。 如新浪微博官方开放了API，我们基于官方API开发一套第三方App名为\"MyWeibo\"。所有新浪微博注册用户都可以使用\"MyWeibo\"进行任何操作。某天新浪微博官方发现使用\"MyWeibo\"的用户发送微博都被加了恶意广告，则新浪微博官方直接封禁\"MyWeibo\"的AppKey即可，\"MyWeibo\"程序不可用，但所有用户仍可正常使用新浪官方微博程序或其他任意客户端使用新浪微博。 2. OpenAPI 2.1 Swagger Swagge是一个与语言无关的规范，用于描述REST API。 Swagger项目已捐赠给OpenAPI计划，现在Swagger也称为OpenAPI。它允许计算机和人员了解服务的功能，而无需直接访问实现（源代码、网络访问、文档）。它解决了为 Web API 生成文档和帮助页的问题，具有诸如交互式文档、客户端 SDK 生成和 API 可发现性等优点。 1) Swagger 规范 Swagger核心是Swagger规范，默认情况下体现为名为swagger.json的文档。它由Swagger Tool Chain（或其第三方实现）根据你的服务生成。它描述了 API 的功能以及使用 HTTP 对其进行访问的方式。它驱动Swagger UI，并由工具链用来启用发现和客户端代码生成。下面是一个缩减的Swagger 规范示例： { \"swagger\": \"2.0\", \"info\": { \"version\": \"v1\", \"title\": \"API V1\" }, \"basePath\": \"/\", \"paths\": { \"/api/Todo\": { \"get\": { \"tags\": [ \"Todo\" ], \"operationId\": \"ApiTodoGet\", \"consumes\": [], \"produces\": [ \"text/plain\", \"application/json\", \"text/json\" ], \"responses\": { \"200\": { \"description\": \"Success\", \"schema\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/TodoItem\" } } } } }, \"post\": { ... } }, \"/api/Todo/{id}\": { \"get\": { ... }, \"put\": { ... }, \"delete\": { ... }, \"definitions\": { \"TodoItem\": { \"type\": \"object\", \"properties\": { \"id\": { \"format\": \"int64\", \"type\": \"integer\" }, \"name\": { \"type\": \"string\" }, \"isComplete\": { \"default\": false, \"type\": \"boolean\" } } } }, \"securityDefinitions\": {} } 2) Swagger UI Swagger UI提供了基于Web的用户界面方便用户直观的查看使用Swagger规范内容。Web UI 如下所示： 控制器中的每个公共操作方法都在Swagger UI中进行测试。单击方法名称可以展开该部分。添加所有必要的参数，然后单击“试试看!”。 2.2 Swagger 集成 目前在.Net Core平台下比较流行的Swagger集成工具有Swashbuckle和NSwag。两者均包含 Swagger UI 的嵌入式版本，因此可使用中间件注册调用将该嵌入式版本托管在 ASP.NET Core 应用中。 Swashbuckle.AspNetCore 是一个开源项目，用于生成 ASP.NET Core Web API 的 Swagger 文档。 NSwag 是另一个用于生成 Swagger 文档并将 Swagger UI 或 ReDoc 集成到 ASP.NET Core Web API 中的开源项目。 此外，NSwag 还提供了为 API 生成 C# 和 TypeScript 客户端代码的方法。 这里我们选择NSwag为例做简述。 安装依赖Nuget包 dotnet add package NSwag.AspNetCore 配置 Swagger。 public void ConfigureServices(IServiceCollection services) { services.AddMvc(); // 注册Swagger服务 services.AddSwaggerDocument(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { //启用中间件生成 Swagger规范 和 Swagger UI app.UseOpenApi(); app.UseSwaggerUi3(); app.UseMvc(); } 查看Swagger UI。默认访问 http://localhost:5000/swagger 3. 开发SDK 开放API除了完善的API文档外，为了更加友好的用户体验，服务提供商还会为常用的技术平台提供SDK包。 SDK包的作用就是按照接口文档，把对所有API的HTTP请求用对应语言平台工具类的方式提供给开发者调用，使用SDK包之后开发者就可以像调用本地工具方法一样使用API，避免了自定义繁琐的HTTP请求等环节。 开发SDK方就是写一个工具包。完成SDK开发后可以共享出来共开发者使用，如.Net平台可以发不到Nuget。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/log.html":{"url":"pages/log.html","title":"8. 日志管理","keywords":"","body":"日志管理 ASP.NET Core 支持适用于各种内置和第三方日志记录提供程序的日志记录 API,并统一了日志操作接口ILogger,同时默认提供了基础日志的Provider。 1. 记录日志 public class HomeController : Controller { private ILogger _logger; public HomeController(ILogger logger) { _logger = logger; } public IActionResult Index() { _logger.LogDebug(\"日志记录测试内容\"); return View(); } } 在Asp.Net Core服务器构建之前的CreateDefaultBuilder中配置了默认的日志服务。我们可以在不做任何配置的情况下直接DI使用默认的日志服务,日志可以在控制台，VS调试窗口和事件查看器中查看到输出入的日志。 更详细的日志使用请参见官方文档 2. 第三方日志组件 Asp.Net Core默认的日志提供程序并没有提供写文件、数据库、邮件等功能，我们可以使用第三方日志提供程序完成,如Nlog。 配置步骤非常简单，按官方文档进行即可。 由于实现了统一的日志接口，替换不同的日志提供程序后，使用日志组件记录日志的代码无需修改，这也体现了面向接口多态编程的好处。 除了前面提到的日志组件，在大型分布式应用或微服务中就需要将分布式应用中分散各处的日志进行统一整理归类，这就需要分布式日志管理，如经典的日志组件 ELK(跨平台)，.Net Core 日志组件 Exceptionless(依赖Windows平台)。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/dapper.html":{"url":"pages/dapper.html","title":"1. Dapper","keywords":"","body":"Dapper 全攻略 1. 简介 2. 项目/模型 3. CRUD 4. 其他 5. Dapper Plus 1. 简介 Dapper是.NET下一个轻量级的ORM框架，它和Entity Framework或Nhibnate不同，属于轻量级的，并且是半自动的。也就是说实体类都要自己写。它没有复杂的配置文件，一个单文件就可以了。Dapper通过提供IDbConnection扩展方法来进行工作。 Dapper没有定义特定的数据库要求，它支持所有ADO.NET支持的数据库，如SQLite,SQL CE,Firebird,Oracle,MySQL,PostgreSQL,SQL Server等。 国外知名网站Stack Overflow生产环境使用Dapper进行数据库访问。 2. 项目/模型 下面我们通过一个简单的.Net Core控制台项目来快速入门Dappper使用。数据库使用MySQL。 2.1 创建项目 # 创建.net core控制台项目 $ dotnet new console -n DapperDemo # 引用Dapper和MySQL nuget包 $ dotnet add package Dapper $ dotnet add package MySql.Data 2.2 数据模型 1) 数据库 CREATE TABLE `article` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Title` varchar(255) NOT NULL, `Content` text NOT NULL, `Status` int(1) NOT NULL DEFAULT '1', `UpdateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `AuthorId` int(11) NOT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `author` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `NickName` varchar(255) NOT NULL, `RealName` varchar(255) NOT NULL, `BirthDate` date DEFAULT NULL, `Address` varchar(255) DEFAULT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `comment` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `ArticleId` int(11) NOT NULL, `Content` varchar(255) NOT NULL, `CreateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2) 数据模型 public abstract class BaseModel { public int Id { get; set; } } public class Author : BaseModel { public string NickName { get; set; } public string RealName { get; set; } public DateTime? BirthDate { get; set; } public string Address { get; set; } public Author() { } public Author(string nickName, string realName) { NickName = nickName; RealName = realName; } } public class Article : BaseModel { public string Title { get; set; } public string Content { get; set; } public ArticleStatus Status { get; set; } public DateTime UpdateTime { get; set; } public int AuthorId { get; set; } public Author Author { get; set; } public IEnumerable Comments { get; set; } } public class Comment : BaseModel { public int ArticleId { get; set; } public Article Article { get; set; } public string Content { get; set; } public DateTime CreateTime { get; set; } } public enum ArticleStatus { Abnormal, Normal } 3. CRUD 建立数据库连接。 private static readonly string _connStr; private static IDbConnection Cnn => new MySqlConnection(_connStr); static DapperPlus() { _connStr = \"Server=127.0.0.1;Database=db_dapper;Uid=root;Pwd=xxxxxx;\"; } 3.1 非查询操作 1) 插入数据 Dapper可以使用同样的方式插入一条或多条数据。 string sql = \"INSERT INTO author (NickName,RealName) VALUES(@nickName,@RealName)\"; var colin = new Author(\"Colin\", \"Colin Chang\"); var robin = new Author(\"Robin\", \"Robin Song\"); using (var cnn = Cnn) { await cnn.ExecuteAsync(sql, new Author[] { colin, robin }); } 2) 更新数据 string sql = \"UPDATE author SET Address=@address WHERE Id=@id\"; using (var cnn = Cnn) { await cnn.ExecuteAsync(sql, new { id = 1, address = \"山东\" }); } 3) 删除数据 string sql = \"DELETE FROM author WHERE Id=@id\"; using (var cnn = Cnn) { await cnn.ExecuteAsync(sql,new {id=2}); } 3.2 查询操作 1) 简单查询 var sql = \"SELECT * FROM author WHERE Id=@id\"; using (var cnn = Cnn) { var authors = await cnn.QueryAsync(sql, new { id = 1 }); } 常用的IN ()方式查询 var sql = \"SELECT * FROM author WHERE Id IN @ids\"; using (var cnn = Cnn) { var authors = await cnn.QueryAsync(sql, new { ids = new int[] { 1, 2 } }); } 2) 多表连接查询 此处演示使用三表连接查询，同时包含1:1和1:N的关系。 var sql = @\"SELECT * FROM article AS ar JOIN author AS au ON ar.AuthorId = au.Id LEFT JOIN `comment` AS c ON ar.Id = c.ArticleId\"; var articles = new Dictionary(); using (var cnn = Cnn) { var data = await cnn.QueryAsync(sql, (article, author, comment) => { //1:1 article.Author=author; //1:N if (!articles.TryGetValue(article.Id, out Article articleEntry)) { articleEntry = article; articleEntry.Comments = new List{}; articles.Add(article.Id, articleEntry); } articleEntry.Comments = articleEntry.Comments.Append(comment); return articleEntry; }); // var result= data.Distinct(); } var result = articles.Values; //data.Distinct()和articles.Values都可以拿到数据，且数据内容相同。 1:N关系的连接查，查询出来的数据都是连接展开之后的全部数据记录，以上代码中的Lambda表达式会在遍历没条数据记录时执行一次。 3) 多结果集查询 Dapper支持多结果集查询，可以执行任意多条查询语句。 // 多结果集查询 string sqls = @\" SELECT * FROM article WHERE Id=@id; SELECT * FROM `comment` WHERE ArticleId=@articleId;\"; using (var cnn = Cnn) { var reader = await cnn.QueryMultipleAsync(sqls, new { id = 1, articleId = 1 }); var articles = await reader.ReadAsync(); var comments= await reader.ReadAsync(); var article = articles.FirstOrDefault(); if (article != null) article.Comments = comments; } 多结果集查询中，配合使用多条存在一定关联关系的查询语句，可以在一定程上巧妙的实现连接查询的效果，避免多表连接查询锁表的问题。以上代码即实现了此种效果。 3. 事务和存储过程 3.1 事务 var scripts = new SqlScript[] { new SqlScript(\"UPDATE article SET UpdateTime=NOW() WHERE Id=@id\",new {id=2}), new SqlScript(\"UPDATE author SET BirthDate=NOW() WHERE Id=@id\",new {id=1}) }; using (var cnn = Cnn) { IDbTransaction tran = null; try { cnn.Open(); tran = cnn.BeginTransaction(); foreach (var script in scripts) await cnn.ExecuteAsync(script.Sql, script.Param, tran, commandType: script.CommandType); tran.Commit(); } catch { tran?.Rollback(); } } 以上演示用到的脚本模型类如下： public class SqlScript { public string Sql { get; set; } public object Param { get; set; } public CommandType CommandType { get; set; } public SqlScript(string sql, object param = null, CommandType cmdType = CommandType.Text) { Sql = sql; Param = param; CommandType = cmdType; } } 3.2 存储过程 Dapper完全支持存储过程。存储过程比较简单，代码就不展示了，读者可以自己按照自己想法随意创建。 using (var cnn = Cnn) { var users = cnn.Query(\"spGetAuthors\", new {Id = 1}, commandType: CommandType.StoredProcedure); } 使用传入传出参数的存储过程。 var p = new DynamicParameters(); p.Add(\"@a\", 11); p.Add(\"@b\", dbType: DbType.Int32, direction: ParameterDirection.Output); p.Add(\"@c\", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue); using (var cnn = Cnn) { cnn.Execute(\"spMagicProc\", p, commandType: CommandType.StoredProcedure); } int b = p.Get(\"@b\"); int c = p.Get(\"@c\"); 4. 其他 4.1 参数替换 Dapper支持对SQL语句中bool和数字类型进行替换。 var sql = \"SELECT * FROM article WHERE Status= {=Normal}\"; using (var cnn = Cnn) { var articles = await cnn.QueryAsync(sql, new {ArticleStatus.Normal}); } 参数替换在特定类型字段中非常好用，比如\"category id\", \"status code\" or \"region\" 参数替换并非采用参数话查询，虽然使用方便但是建议经过测试后谨慎使用。 4.2 缓存查询 默认情况下Dapper会对执行SQL后的整个reader进行缓存，以减少数据库锁定和网络请求时间。然而执行大批量查询操作时缓存会占用大量内存空间，此时执行查询操作可以设置buffered: false 以禁用缓存。 4.3 ANSI编码 Dapper支持varchar类型参数,如果查询语句需要过滤一个varchar类型的字段可以使用以下方式指定编码: Query(\"select * from Author where Address = @address\", new {address = new DbString { Value = \"山东\", IsFixedLength = true, Length = 10, IsAnsi = true }); SQL Server中查询unicode and ANSI字段时务必使用unicode编码 4.4 多数据类型行 某些情况下同一行数据的某个字段可以是不同的数据类型。这种情况使用IDataReader.GetRowParser非常方便。 有shapes表结构如上图，我们可以根据Type字段将每行数据映射为Circle,Square,Triangle等具体类型对象。以下为示例代码： var shapes = new List(); using (var reader = connection.ExecuteReader(\"select * from Shapes\")) { // Generate a row parser for each type you expect. // The generic type is what the parser will return. // The argument (typeof(*)) is the concrete type to parse. var circleParser = reader.GetRowParser(typeof(Circle)); var squareParser = reader.GetRowParser(typeof(Square)); var triangleParser = reader.GetRowParser(typeof(Triangle)); var typeColumnIndex = reader.GetOrdinal(\"Type\"); while (reader.Read()) { IShape shape; var type = (ShapeType)reader.GetInt32(typeColumnIndex); switch (type) { case ShapeType.Circle: shape = circleParser(reader); break; case ShapeType.Square: shape = squareParser(reader); break; case ShapeType.Triangle: shape = triangleParser(reader); break; default: throw new NotImplementedException(); } shapes.Add(shape); } } 5. Dapper Plus Dapper仅提供了SqlHelper常用功能和对象映射，我们通常会对Dapper进行二次封装扩展以更方便的使用Dapper。 下面Dapper扩展在无损Dapper性能的前提下，基本覆盖了日常数据操作，仅供参考。 代码已上传到Github，这里不再展开。 https://github.com/colin-chang/DapperHelper 具体使用方式可以查看单元测试 https://github.com/colin-chang/DapperHelper/blob/master/ColinChang.DapperHelper.Test/DapperPlusTest.cs 该帮助类已发布到Nuget # Package Manager Install-Package ColinChang.DapperHelper # .NET CLI dotnet add package ColinChang.DapperHelper © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/docker-intro.html":{"url":"pages/docker-intro.html","title":"1.1 Docker简介","keywords":"","body":"Docker — 领先的软件容器平台 1. What's the problem 2. Docker特点 3. Docker基本概念 3.1 镜像(Image) 3.2 容器(Container) 3.3 仓库(Repository) 4. 容器与虚拟机 1. What's the problem 系统开发常遇到以下问题： A电脑运行没问题,B电脑上运行有问题。俗称“我这里没问题呀”🤦‍‍‍🤦‍🤦‍ 服务器只运行一个应用\b造成资源浪费,但是运行多个应用又怕互相干扰 在开发人员电脑上开发的系统,跑到服务器上时需要重新安装软件、安装开发包、系统配置,不同系统上可能操作还不一样 ... 以上问题可以用虚拟机技术解决,但是性能低,硬件浪费严重。于是Docker技术应用而生。 2. Docker特点 Docker 是世界领先的软件容器平台,具有以下特点。 轻量 Docker在操作系统上分出多个独立的区域，称作“容器”(Container)。各个容器之间互相“基本隔离”,每个容器可以单独有自己的系统配置、安装的软件、安装 的开发包,各个容器之间的软件“基本”不会互相干扰。在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。Docker性能损耗比虚拟机低很多,都是进程跑在原生操作性系统下,基本没有性能损耗。 标准化 Docker 容器基于开放式标准。能够在不同平台环境下快速的移植，而不用担心运行环境的变化导致应用无法正常运行的情况。目前支持Linux/Windows/MacOS, 但不支持32位系统。 伸缩性 Docker还可以更好的满足对于可伸缩性的要求。Docker可以按需自动扩容,自动启动多个服务器、创建多个容器运行更多集群服务器。 即抛性 Docker部署系统要求可以“即抛”,不保存状态数据。一个容器不再使用时，直接删除即可,不会保存相关数据。 安全性 Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。 3. Docker基本概念 3.1 镜像(Image) 操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu 16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 Docker 设计时，就充分利用 Union FS的技术，将其设计为 分层存储的架构 。 镜像实际是由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。 分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。 3.2 容器(Container) 镜像（ Image ）和容器（ Container ）的关系，就像是面向对象程序设计中的 类 和 实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。 前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 3.3 仓库(Repository)   镜像构建完成后，可以很容易的在当前宿主机上运行，但如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个仓库(Repository)；每个仓库可以包含多个标签(Tag)；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 : 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，14.04 ,16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为 ubuntu:latest 。 仓库名经常以两段式路径形式出现，比如 jwilder/nginx-proxy ，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。 1) Docker Registry 公开服务 Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。 最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。 由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（ Registry Mirror ），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。 2) 私有 Docker Registry 除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了Docker Registry 镜像，可以直接使用做为私有 Registry 服务。 开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。 除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。 4. 容器与虚拟机 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。 虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个 VM 在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 占用大量空间 。而且 VM 启动也十分缓慢 。 两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker通常用于隔离不同的应用 ，例如前端，后端以及数据库。 参考文献 https://blog.csdn.net/aa1215018028/article/details/80823659 https://blog.csdn.net/wo18237095579/article/details/80480882 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/docker-install.html":{"url":"pages/docker-install.html","title":"1.2 安装配置","keywords":"","body":"Docker 安装配置 1. 安装Docker 2. 加速器和镜像市场 1. 安装Docker Docker安装方法可以参考官网步骤。 Windows和MacOS中可以都可以使用Docker Desktop，界面化操作表简单，此处不作介绍。下面我们以Ubuntu 18.04为例讲解安装步骤。 # 安装docker $ sudo apt install docker.io # 查看docker版本 $ sudo docker version # 查看 docker 系统信息 $ sudo docker info # 下载镜像，如mysql $ sudo docker pull mysql 2. 加速器和镜像市场 国内访问Docker Hub可能速度比较慢。我们可以考虑使用加速器和镜像市场。加速器是代理服务器,最终还是访问官方网站,和官网一致和镜像市场的区别，如阿里云或者 DaoCloud 等加速器。镜像市场是私服,不和官网一致，如DaoCloud 镜像市场等。 1）镜像市场 如果使用国内镜像市场镜像直接使用docker pull命令拉取即可，一般镜像市场都用使用说明。如 # 拉取DaoCloud镜像市场的MySQL $ docker pull daocloud.io/library/mysql 2）加速器 使用镜像加速器可以按照第三方加速器说明配置即可，如 DaoCloud加速器 3. 配置docker用户组 Linux中每次执行docker指令都需要sudo比较麻烦，我们可以把操作用户加入docker用户组来解决。 # 添加docker用户组 $ sudo groupadd docker # 将当前操作用户添加到docker组 $ sudo gpasswd -a CurrentUserName docker # CurrentUserName为当前操作的用户名 # 重启docker服务 $ sudo service docker restart # 注销用户后重新登录即可 $ logout © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/docker-cmd.html":{"url":"pages/docker-cmd.html","title":"1.3 常用命令","keywords":"","body":"Docker 常用命令 命令 说明 docker run/creat 运行或创建容器 docker start/stop/restart 启动/停止/重启容器 docker ps 列出容器 docker images 列出本地镜像 docker build 列出本地镜像 docker rm/rmi 删除容器或镜像 docker exec/attach 进入容器 docker logs [OPTIONS] CONTAINER 查看日志 Docker操作的相关指令非常多，详细的使用方法可以参考官方文档，此处我们只列举部分常用命令及其使用注意事项。 Docker命令格式一般形如： docker [command] [OPTIONS] ，例如 # 查看docker帮助文档 $ docker -h # 查看docker版本信息 $ docker version # 查看docker系统信息，如镜像和容器信息，docker版本，CPU/内存，系统架构等 $ docker info 1.docker run/creat docker run命令用于创建并启动指定镜像的一个容器。容器进程是独立和相对封闭的，其拥有独立的文件系统，网络配置，进程树等，类似于一个微型的系统。详细使用方式参见官方文档。docker create用于创建一个一个容器但不启动，语法与docker run相同。 # 命令格式 $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] options 含义 -i 以交互模式运行容器，通常与 -t 同时使用 -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 -d 后台运行容器，并返回容器ID -p 端口映射。格式为：宿主端口(host port):容器端口(container port) -e 设置环境变量 -v 挂载卷。如docker run -p 80:80 -v /data:/data -d nginx以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data --name 指定容器名称，不指定则会由系统产生一个随机名字 --link 添加链接到另一个容器。如docker run -p 80:80 --link lottery:web nginx运行nginx容器并连链接lottery容器同时指定lottery容器链接别名为web。链接可以实现容器间相互访问。 --restart 容器退出后重启策略。默认为no。可选项no,always,unless-stopped,on-failure[:max-retries] $ docker run \\ -d \\ # 后台方式运行 --name my-mysql \\ # 命名当前容器为mac-mysql -e MYSQL_ROOT_PASSWORD=pwd \\ # 指定root用户密码为pwd mysql # 运行mysql容器 $ docker run \\ -it \\ # 前台终端交互方式运行 --name my-lottery \\ # 命名当前容器为my-lottery --link my-mysql:mysql # 链接到名称为my-mysql的容器并指定别名为mysql lottery # 运行lottery容器 $ docker run \\ -d \\ # 后台方式运行 --name my-nginx \\ # 命名当前容器为my-nginx -p 8000:80 \\ # 宿主机8000端口映射为容器80端口 -v ~/nginx/default.conf:/etc/nginx/conf.d/default.conf \\ # 宿主机~/nginx/default.conf挂载到容器为/etc/nginx/conf.d/default.conf --link my-lottery:web \\ # 链接到名称为lottery的容器并指定别名为web --restart always \\ # 退出后总是自动重启 nginx # 运行nginx容器 2. docker start/stop/restart docker start :启动一个或多个已经被停止的容器 docker stop :停止一个运行中的容器 docker restart :重启容器 # 命令格式 $ docker start [OPTIONS] CONTAINER [CONTAINER...] # 启动容器 my_container $ docker start my_container # 停止容器 my_container $ docker stop my_container # 重启容器 my_container $ docker restart my_container 3. docker ps docker ps用于列出容器。 # 命令格式 docker ps [OPTIONS] options 含义 -a 显示所有的容器。不指定则默认只显示正在运行的容器 -f 根据条件过滤显示的内容 -l 显示最近创建的一个容器 -n 列出最近创建的n个容器 -q 仅显示容器简短Id -s 显示总的文件大小 每个容器都有唯一的\"CONTAINER ID\"和NAME。ID有完整长ID和简短ID，两者都可以标识容器。 # 显示所有容器ID $ docker ps -aq # 显示所有lottery镜像的容器 $ docker ps -a -f=ancestor=lottery 4. docker images docker images用于列出本地镜像。 # 命令格式 $ docker images [OPTIONS] [REPOSITORY[:TAG]] options 含义 -a 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层） -f 显示满足条件的镜像 -q 只显示镜像ID # 列出本地镜像 $ docker images 5. docker build docker build命令可以使用Dockerfile构建镜像。Dockerfile相关内容参见制作镜像。 # 命令格式 $ docker build [OPTIONS] PATH | URL | - options 含义 -t 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签 -f Dockerfile名称。(默认为 ‘PATH/Dockerfile’) --pull 尝试去更新镜像的新版本 # 在当前目录下使用Dockerfile构建名为\"colin/webapp\"的镜像，tag为1.0 $ docker build -t colin/webapp:1.0 . 6. docker rm/rmi 6.1 docker rm docker rm用于删除容器。删除容器之前需要先停止容器。 options 含义 -f 通过SIGKILL信号强制删除一个运行中的容器 -l 移除容器间的网络连接，而非容器本身 -v -v 删除与容器关联的卷 # 删除my-nginx容器 $ docker rm my-nginx # 删除所有容器 $ docker rm $(docker ps -aq) # 删除所有ubuntu镜像的容器 $ docker rm $(docker ps -aq -f=ancestor=ubuntu) 6.2 docker rmi docker rmi用于删除镜像。删除容器之前需要先停止容器。删除镜像之前必须把所有这个镜像的容器删除。使用docker image rm指令也可以删除镜像。 # 删除所有nginx镜像的容器 $ docker rm $(docker ps -aq -f=ancestor=nginx) # 删除nginx镜像 $ docker rmi nginx 7. docker exec/attach 进入Docker容器有多种方式，这里我们介绍最简单的docker attach和docker exec两种方式 7.1 docker attach docker attach用于附加本地终端输入输出及错误流信息到一个运行中的容器。如果容器创建时未指定交互式(-it)运行，可能无法通过docker attach进入到容器中。为了确保可以通过docker attach进入容器，执行docker run时需要指定-it，并在启动后执行/bin/bash。如 docker run -itd --name mysql -e MYSQL_ROOT_PASSWORD=pwd mysql /bin/bash docker attach命令进入容器后，可以使用Ctrl+C，Ctrl+D,exit等方式退出，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。退出还可能会导致容器关闭，在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。 docker attach有诸多不便之处，推荐使用docker exec方式进入容器替代。 $ docker attach --sig-proxy=false mysql 7.2 docker exec docker exec可以进入容器内执行命令。使用方式比较简单，详见官方文档 # 进入my-nginx容器并开启一个交互式终端 $ docker exec -it my-nginx /bin/bash 8. docker logs docker logs用于查看指定容器的日志。 # 命令格式 $ docker logs [OPTIONS] CONTAINER options 含义 -f 跟踪日志输出 --details 显示详细日志 --tail 从最新日志起算，输出日志行数 -t 显示日志记录时间 --since 输出指定时间之后的日志。时间格式：2013-01-02T13:23:37 until 输出指定时间之前的日志。时间格式：2013-01-02T13:23:37 # 输出nginx容器最新的10条日志 $ docker logs -ft --tail 10 nginx © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/docker-dockerfile.html":{"url":"pages/docker-dockerfile.html","title":"1.4 制作镜像","keywords":"","body":"制作镜像 1. 镜像简介 2. Dockerfile 指令 3. 制作网站镜像 1. 镜像简介 Docker容器是一个相对独立运行的Linux服务器环境，在其中部署了我们需要的各种环境和服务，而这些都是在Docker镜像中定义的。 Docker容器最终多作为一个服务提供者角色（微服务）而存在，如MySQL,Nginx,Redis等镜像的容器。此外也有很多镜像只搭建一些特定的环境，并未直接提供服务，此种镜像多作为被继承者为其它镜像提供基础层，如microsoft/dotnet(.net core),python等。我们常在此类镜像基础上部署自己的网站或服务，打包成自定义镜像。 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。我们通过docker pull IMAGE来获取使用他人公开的镜像。也可以通过Dockerfile来定制自己的镜像。 Dockerfile构建的镜像只能在本地使用，上传到DockerHub或者自己的搭建私服后才可以供别人使用。 如下是自定义mysql镜像Dockerfile示例(mysql官方有公开镜像，此处仅作示例之用)。 FROM ubuntu RUN echo 'mysql-server mysql-server/root_password password root'|debconf-set-selections RUN echo 'mysql-server root'|debconf-set-selections RUN apt-get update RUN apt-get install -y mysql-server RUN /etc/init.d/mysql restart &&\\ mysql -uroot -proot -e \"grant all privileges on *.* to 'root'@'%' identified by 'root'\" &&\\ mysql -uroot -proot -e \"show databases;\" EXPOSE 3306 CMD [\"/etc/init.d/mysql\",\"restart\"] 2. Dockerfile 指令 options 含义 FROM 表示当前镜像继承自哪个镜像 WORKDIR 指定工作目录 CP 将宿主机文件或目录拷贝到容器中 RUN 镜像构建时执行命令。多用作预装软件修改配置等 EXPOSE 服务允许暴露端口 CMD/ENTRYPOINT 镜像容器启动时执行命令。多用于启动服务、运行程序等 每个Dockerfile只能有一条CMD命令，如果指定了多条,只有最后一条会被执行。 如果容器启动时不指定参数,则CMD和ENTRYPOINT是一样的。否则CMD指定的命令会被docker run 的容器参数覆盖, 而ENTRYPOINT则会把容器参数传递给自身指定的命令。 通过以下案例简单可以证明以上CMD和ENTRYPOINT的区别。 1) 有使用CMD的Dockerfile如下: FROM ubuntu CMD [\"uname\"] 创建并启动容器。 # 构建镜像 $ docker build -t cmd . # 创建并启动容器 $ docker run -it cmd # 输出 Linux $ docker run -it cmd -a # 错误输出。\"-a\": executable file not found in $PATH\" $ docker run -it cmd whoami # 输出 root 以上案例中，容器启动时-a和whoami参数都将覆盖镜像中CMD指定的uname命令。所以最终运行的分别是-a和whoami指令。-a指令不存在所以运行报错，whoami指令则输出当前用户root。 2) 有使用ENTRYPOINT的Dockerfile如下: FROM ubuntu ENTRYPOINT [\"uname\"] 创建并启动容器。 # 构建镜像 $ docker build -t entrypoint . # 创建并启动容器 $ docker run -it entrypoint # 输出 Linux $ docker run -it entrypoint -a # 输出 Linux 06968e7efc5d 4.9.125-linuxkit #1 SMP Fri Sep 7 08:20:28 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux $ docker run -it entrypoint whoami # 错误输出 uname: extra operand 'whoami' 以上案例中，容器启动时-a和whoami参数都将作为ENTRYPOINT指定的uname命令的参数。所以最终运行的分别是uname -a和uname whoami指令。whoami参数非法所以最后一条命令报错。 RUN 是构建镜像时执行的指令,用于安装软件、修改配置等初始化的代码, 可以执行多条; CMD 相当于镜像的默认开机指令,只能指定一条 CMD,容器运行参数可以覆盖 CMD; ENTRYPOINT 用于把镜像容器打造成可执行程序,容器运行参数作为可执行程序的参数; 3. 制作网站镜像 此处我们简单演示制作一个基于asp.net core的网站镜像，其他镜像制作大同小异。 假定我们网站程序已经构建完成并发布，此Dockerfile位于网站发布目录中。 FROM microsoft/dotnet:2.2-aspnetcore-runtime # 基于asp.net core 2.2 runtime官方镜像制作本镜像 COPY . /publish # 将宿主机当前目录下所有内容拷贝到镜像的/publish目录中 WORKDIR /publish # 设定当前工作目录为/publish EXPOSE 5000/tcp # 暴露tcp协议5000端口 CMD [\"dotnet\",\"WebApp.dll\"] # 容器启动执行 dotnet WebApp.dll命令 创建并启动网站容器。 $ docker build -t colin/webapp:1.0 . # 在当前目录下使用Dockerfile构建镜像命名为colin/webapp，tag为1.0 $ docker run \\ -d \\ --name webapp \\ -p 8000:5000 \\ --restart always \\ colin/webapp:1.0 # 创建并启动容器 完成以上操作后在宿主机通过 http://127.0.0.1:8000 即可访问我们的网站，如果需要暴露到外网，根据微软建议最好使用nginx等服务器作反代。 除了以上使用网站已发布内容构建Docker镜像，我们也可以在镜像构建过程中完成源码编译、测试，发布，部署等过程。以lottery项目为例 FROM microsoft/dotnet:2.2-sdk AS build WORKDIR /app # copy csproj and restore as distinct layers COPY *.sln . COPY Colin.Lottery.WebApp/*.csproj ./Colin.Lottery.WebApp/ COPY Colin.Lottery.DataService/*.csproj ./Colin.Lottery.DataService/ COPY Colin.Lottery.Analyzers/*.csproj ./Colin.Lottery.Analyzers/ COPY Colin.Lottery.Collectors/*.csproj ./Colin.Lottery.Collectors/ COPY Colin.Lottery.Models/*.csproj ./Colin.Lottery.Models/ COPY Colin.Lottery.Common/*.csproj ./Colin.Lottery.Common/ COPY Colin.Lottery.Utils/*.csproj ./Colin.Lottery.Utils/ WORKDIR /app/Colin.Lottery.WebApp/ RUN dotnet restore # copy and publish app and libraries WORKDIR /app/ COPY Colin.Lottery.WebApp/. ./Colin.Lottery.WebApp/ COPY Colin.Lottery.DataService/. ./Colin.Lottery.DataService/ COPY Colin.Lottery.Analyzers/. ./Colin.Lottery.Analyzers/ COPY Colin.Lottery.Collectors/. ./Colin.Lottery.Collectors/ COPY Colin.Lottery.Models/. ./Colin.Lottery.Models/ COPY Colin.Lottery.Common/. ./Colin.Lottery.Common/ COPY Colin.Lottery.Utils/. ./Colin.Lottery.Utils/ WORKDIR /app/Colin.Lottery.WebApp/ RUN dotnet publish -c Release -o out FROM build AS testcollector WORKDIR /app/Colin.Lottery.Collectors.Test COPY Colin.Lottery.Collectors.Test/. . ENTRYPOINT [\"dotnet\", \"test\", \"--logger:trx\"] FROM build AS testanalyzer WORKDIR /app/Colin.Lottery.Analyzers.Test COPY Colin.Lottery.Analyzers.Test/. . ENTRYPOINT [\"dotnet\", \"test\", \"--logger:trx\"] FROM microsoft/dotnet:2.2-aspnetcore-runtime AS runtime WORKDIR /app COPY --from=build /app/Colin.Lottery.WebApp/out ./ ENTRYPOINT [\"dotnet\", \"Colin.Lottery.WebApp.dll\"] 以上如果代码编译或测试出错则网站镜像构建通过，一定程度上避免了程序发布错误。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/microservice-intro.html":{"url":"pages/microservice-intro.html","title":"2.1 微服务架构","keywords":"","body":"微服务架构 1. 单体结构 缺点: 只能采用同一种技术,很难用不同的语言或者语言不同版本开发不同模块; 系统耦合性强,一旦其中一个模块有问题,整个系统就瘫痪了;一旦升级其中一个模块,整个系统就停机了; 要上线必须一起上线,互相等待,无法快速响应需求; 集群只能是复制整个系统,即使只是其中一个模块压力大。 随着现在 IT 系统规模的扩大、模块的剧增,传统的系统架构已经难以满足要求,因此近几年微服务架构开始流行。 2. 微服务 优点: 可以用不同的语言或者语言不同版本开发不同模块; 系统耦合性弱,其中一个模块有问题,可以通过“降级熔断”等手段来保证系统不雪崩; 可以独立上线,能够迅速响应需求; 可以对不同模块用不同的集群策略,哪里慢集群哪里。 缺点: 开发难度大,系统结构更复杂; 运行效率低; 不仅是阿里、腾讯等大公司在大面积使用微服务架构,很多中小公司的 IT 系统架构也是微服务架构流行了。但是不是所有项目都适合微服务,没有“银弹”。 微服务架构要处理哪些问题:服务间通讯;服务治理与服务发现;网关和安全认证;限流与容错;监控等; 第一代微服务:Dubbo(Java)、Orleans(.Net)等;和语言绑定紧密。 第二代微服务:Spring Cloud 等;适合混合开发,正当年。 第三代微服务:Service Mesh(Service Fabric、Istio、Conduit 等)。目前还在快速发展中,更新迭代比较快。 3. 微服务选型 Spring Cloud 是使用 Java 开发的,使用 Java 在 Spring Cloud 下开发最爽,使用steelto 这个开发包也是可以使用.Net Core 开发 Spring Cloud 下的微服务,但 是开发体验没有 Java 那么效率高,而且支持的软件版本更新没有 Java 那么快,使用 Zuul 等 的时候还可能需要写一些 Java 代码。 因此,如果整个项目的技术栈是 Spring Cloud 的,那么.Net Core 开发者可以借助于 steelto “寄居”。如果自己有技术栈的选择权,那么可以自己搭建更亲近.Net Core 的微服务框架。 Service Fabric 是微软开源的微软内部使用的第三代微服务框架,可以使用.Net Core 开发, 也可以使用 Java 开发。但是目前开源的版本还不太适合普通厂商使用(难度;跨平台;通 用性;支持私有云,但是难度大),慎用。愿意花钱在 Azure 云上用 SF,可以用。但是如果 想搭建 SF 私有云,慎用。 如果选择.Net Core 技术栈的第二代微服务框架,推荐使用腾讯(微信支付清算网关)在 使用架构:Consul + Ocelot + .Net Core+Polly + ... 在微服务中,服务之间的通讯有两种主要形式: Restful,也就是传输 Json 格式数据。.Net 中就是对应 WebAPI 技术,不精通 WebAPI 也没关系,和 ASP.Net MVC 差不多,可以使用 PostMan 方便的调试 Restful 接口。 二进制 RPC:二进制传输协议,比 Restful 用的 Http 通讯效率更高,但是耦合性更强。技术有 Thrift、gRPC 等。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/microservice-consul.html":{"url":"pages/microservice-consul.html","title":"2.2 服务治理","keywords":"","body":"Consul 服务治理 1. 服务治理简介 2. Consul 服务安装 3. 服务注册、注销、健康检查 4. 服务发现 4.1 服务发现和消费 4.2 客户端负载均衡 4.3 RestTemplate 1. 服务治理简介 服务治理包括，服务注册、注销、健康检查、服务发现等过程。 微服务架构中，所有服务都会注册到注册中心，客户端需要消费服务时，需要先到注册中心查询对应服务集群，然后按照一定的负载均衡策略消费服务即可。注册中心除了提供服务注册，服务查询工作外，还会按照一定机制对所有注册的服务进行健康检查，以维护服务的可用性。 负载均衡策略在客户端，称为客户端负载均衡。当然也可以设置负载均衡服务器专门负责负载均衡任务。注册中心是在服务器机房环境，其消费者也是服务器机房环境内网的其他服务程序，不会对外网公开，所以这里说的客户端负载均衡中客户端消费程序是指服务器中的某个服务而非真正的用户端，所以这里所说客户端负载均衡也是相对可靠的。 注册中心有很多实现，如Consul,Eureka,Zookeeper等。这里我们选择\b Consul。 2. Consul 服务安装 这里我们直接通过Docker方式安装并部署Consul服务。 # 此中配置仅用于开发。详细配置参见 https://hub.docker.com/_/consul $ docker pull consul $ docker run -d --name=consul-dev -e CONSUL_BIND_INTERFACE=eth0 -p 8500:8500 consul 这里暂且只用一台Consul服务器做演示用，生产环境中为了保证注册中心可用性要做注册中心服务集群,每个集群节点至少有一个（通常会有3到5个）Server，和若干Client组成。 Consul服务部署完成后直接通过 http://127.0.0.1:8500 即可访问其Web控制台。 3. 服务注册、注销、健康检查 连接 Consul 服务器需要借助 Consul驱动。 $ dotnet add package Consul 在.NET Core中微服务一般体现为WebAPI项目，可以方便地使用HTTP协议进行服务间通信。 生产环境中每个服务一般都会存在一个集群，互为备份，保证系统可用性。WebAPI项目默认启动监听 http://5000， 单机启动多个服务实例时需要区别端口，我们可以在程序启动时动态指定端口，或者使用docker做端口映射。 1) 配置文件 使用默认配置文件 appsettings.json,Build Action为Content,Copy to output directory为Copy always 在appsettings.json中添加如下配置。配置内容根据实际环境修改即可。 { \"BindHosts\": [ \"192.168.31.191\" ], \"ConsulClient\": { \"Address\": \"http://127.0.0.1:8500\", \"Datacenter\": \"dc1\" } } 2) 添加健康检查API [Route(\"api/[controller]\")] [ApiController] public class HealthController : ControllerBase { [HttpGet] public ActionResult Get() { return Ok(); } } 3) 修改启动配置 public class Program { public static void Main(string[] args) { /* * 程序启动时必须指定端口号，命令格式为 dotnet run --port 5000 * * 通过docker方式运行时要显式指定 ENTRYPOINT 参数。 形如 docker run xxx --port 5000 */ var config = new ConfigProvider(args); // 端口 var portStr = config[\"port\"]; if (string.IsNullOrWhiteSpace(portStr)) throw new ArgumentNullException(\"port\", \"Please choose a port for current service\"); if (!int.TryParse(args[1], out var port)) throw new ArgumentException(\"porn must be a number\"); if (port 65535) throw new ArgumentOutOfRangeException(\"port\", \"Invalid port,it must between 1024 and 65535\"); // IP var bindHosts = ConfigProvider.GetAppSettings>(\"BindHosts\"); var urls = bindHosts.Select(host => $\"http://{host}:{port}\").ToList(); CreateWebHostBuilder(args, urls.ToArray()).Build().Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args, string[] urls) => WebHost.CreateDefaultBuilder(args) .UseUrls(urls) .UseStartup(); 4) 服务注册注销 public async void Configure(IApplicationBuilder app, IHostingEnvironment env, IApplicationLifetime applicationLifetime) { app.UseMvc(); await Register2Consul(applicationLifetime); } private async Task Register2Consul(IApplicationLifetime applicationLifetime) { var serviceName = Assembly.GetEntryAssembly().GetName().Name; var serviceId = $\"{serviceName}_{Guid.NewGuid()}\"; //Consul 配置 void ConsulConfig(ConsulClientConfiguration ccc) { ccc.Address = new Uri(Configuration[\"ConsulClient:Address\"]); ccc.Datacenter = Configuration[\"ConsulClient:Datacenter\"]; } //注册服务到Consul using (var client = new ConsulClient(ConsulConfig)) { var hosts = new List(); Configuration.Bind(\"BindHosts\", hosts); var ip = hosts.LastOrDefault(); var port = Convert.ToInt32(Configuration[\"port\"]); await client.Agent.ServiceRegister(new AgentServiceRegistration { ID = serviceId, //服务编号 Name = serviceName, //服务名称 Address = ip, //服务地址，一般绑定本机内网地址 Port = port, // 服务端口 Check = new AgentServiceCheck { DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5), // 服务停止多久后从Consul中注销 Interval = TimeSpan.FromSeconds(10), //健康检查间隔(心跳时间) HTTP = $\"http://{ip}:{port}/api/health\", //健康检查地址 Timeout = TimeSpan.FromSeconds(5) //检查超时时间 } }); } //程序退出时候 从Consul注销服务 applicationLifetime.ApplicationStopped.Register(async () => { using (var client = new ConsulClient(ConsulConfig)) { await client.Agent.ServiceDeregister(serviceId); } }); } 启动两个服务实例后，在Consul中可以看到这个服务信息。 $ dotnet SmsService.dll --port 8000 $ dotnet SmsService.dll --port 8001 服务刚启动时会有短暂的 Failing 状态。服务正常结束(Ctrl+C)会触发 ApplicationStopped,正常注销。即使非正常结束也没关系,Consul 健康检查过一会发现服务器死掉后也会主动注销。如果服务器刚刚崩溃,但是还买来得及注销,消费的使用者可能就会拿到已经崩溃的实 例,这个问题通过后面讲的重试等策略解决。 服务只会注册 ip、端口,consul 只会保存服务名、ip、端口这些信息,至于服务提供什么接口、方法、参数,consul 不管,需要消费者知道服务的这些细节。 4. 服务发现 这里用控制台测试,真实项目中服务消费者同时也可能是另外一个 Web 应用(比如 Web 服务器调用短信服务器发短信)。 4.1 服务发现和消费 using (var consulClient = new ConsulClient(c => c.Address = new Uri(\"http://127.0.0.1:8500\"))) { //获取所有注册的服务实例 var services = await consulClient.Agent.Services(); //遍历并消费服务 foreach (var service in services.Response.Values) Console.WriteLine($\"id={service.ID},name={service.Service},ip={service.Address},port={service.Port}\"); } 4.2 客户端负载均衡 我们可以按照实际需求自定义负载均衡策略，这里我们使用当前TickCount与服务实例数取模的方式达到随机获取一台服务器实例的效果，当然在一个毫秒之类会所有请求都压给一台服务器。也可以自己写随机、轮询等客户端负载均衡算法,也可以自己实现按不同权重分配(注册时候 Tags 带上配置、权重等信息)等算法。 using (var consulClient = new ConsulClient(c => c.Address = new Uri(\"http://127.0.0.1:8500\"))) { //获取所有注册的\"人脸识别\"服务 var faceRecogonitionServices = consulClient.Agent.Services().Result.Response.Values .Where(s => s.Service.Equals(\"Xiaoyang.FaceRecognition\", StringComparison.OrdinalIgnoreCase)); if (faceRecogonitionServices.Any()) { //使用 当前时间毫秒数量%人脸服务实例数 随机获得一个服务实例，实现复杂均衡 var frs = faceRecogonitionServices.ElementAt(Environment.TickCount % faceRecogonitionServices.Count()); Console.WriteLine($\"{frs.Address}:{frs.Port}\"); } } 4.3 ConsulRestHelper 注册中心可以把形如\"http://ProductService/api/Product/\" 的虚拟地址请求按照客户端负载均衡算法解析为形如 http://192.168.1.10:8080/api/Product/ 的真实地址。虚拟地址转化和请求处理过程都是重复性的操作，我们可以仿照 Spring Cloud自己封装一个ConsulRestHelper 帮助类来处理客户端请求服务的过程。其主要功能包括： 服务发现。 根据url中服务名获取一个服务实例,把虚拟路径转换为实际连服务器路径; 服务消费者无需指定服务提供者,实现解耦。 负载均衡。这里用的是简单的随机负载均衡, 处理客户端请求响应内容。 ConsulRestHelper 已经发布到Nuget. 服务的注册、消费都是在系统内部服务器之间的进行,终端用户无法访问到Consul。如Web服务器对终端用户来讲的是否服务端，而其在服务治理中的角色则是作为客户端消费者。 使用示例： using (var httpClient = new HttpClient()) { var rest = new ConsulRestHelper(httpClient,\"http://127.0.0.1:8500\"); var headers = new HttpRequestMessage().Headers; headers.Add(\"Authorization\", \"Bearer token\"); var ret1 = await rest.GetForEntityAsync(\"http://Xiaoyang.FaceRecognition/api/values\", headers); if (ret1.StatusCode == HttpStatusCode.OK) Console.WriteLine(string.Join(\",\", ret1.Body)); } © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/microservice-polly.html":{"url":"pages/microservice-polly.html","title":"2.3 熔断降级","keywords":"","body":"熔断降级 1. 熔断降级 熔断就是“保险丝”。当出现某些状况时,切断服务,从而防止应用程序不断地尝试执行可能会失败的操作给系统造成“雪崩”,或者大量的超时等待导致系统卡死。 熔断降级在这里只是一种统称，泛指微服务的异常处理策略。简单来讲就是出现当服务出现某些故障时按照设定执行某些相应的操作，避免因局部服务故障对整体系统的影响。出现某种故障执行设定的动作，这称之为“策略”。 降级的目的是当某个服务提供者发生故障的时候,向调用方返回一个错误响应或者替代响应。例如，调用联通接口服务器发送短信失败之后,改用移动短信服务器发送,如果移动短信服务器也失败,则改用电信短信服务器,如果还失败,则返回“失败”响应;在从推荐商品服务器加载数据的时候,如果失败,则改用从缓存中加载,如果缓存中也加载失败,则返回一些本地替代数据。 2. Polly 简介 .Net Core 中有一个被.Net 基金会认可的库 Polly,可以用来简化熔断降级的处理。主要功能:降级(FallBack);重试(Retry);断路器(Circuit-breaker);超时检测(Timeout);缓存(Cache); Polly介绍参考 https://www.cnblogs.com/CreateMyself/p/7589397.html Polly 的策略由“故障”和“动作”两部分组成。“故障”包括异常、超时、返回值错误等情况。“动作”包括 FallBack(降级)、重试(Retry)、熔断(Circuit-breaker)等。 策略用来执行可能会有有故障的业务代码,当业务代码出现“故障”中情况的时候就执行“动作”。 3. Polly 使用 Polly提供了Nuget包，执行dotnet add package Polly安装即可。 3.1 异常处理 常用的异常处理策略包括 FallBack(降级)、重试(Retry)、熔断(Circuit-breaker). 3.1.1 降级 降级处理允许服务出现指定故障时执行指定的降级操作。故障被降级处理后不会再抛出异常。 以下代码当发生ArgumentException异常的时候,执行Fallback代码。在Execute()中执行可能导致故障的业务代码。 await policy.handle() //故障 .fallbackasync(async _ => // 动作 { // 执行策略动作 console.writeline(\"执行策略动作\"); }, async ex => { // 记录异常信息 console.writeline(ex.message); }) .executeasync(() => { //执行业务代码 console.writeline(\"开始业务\"); throw new argumentexception(\"出现参数错误异常\"); console.writeline(\"结束业务\"); }); 如果出现了Handle中未约定的异常，异常会被抛出，可以使用Handle来处理所有类型的异常。也可以使用Or方法处理多种异常。 await Policy.Handle() .Or() .Or() .FallbackAsync(async _ => Console.WriteLine(\"策略动作\")) .ExecuteAsync( () => { Console.WriteLine(\"开始业务\"); throw new NullReferenceException(); }); 如果策略的业务代码中有返回值。可以使用泛型的Policy类。 var value = await Policy .Handle() .FallbackAsync(async _ => { Console.WriteLine(\"执行出错\"); return await Task.FromResult(\"降级返回值\"); }) .ExecuteAsync(async () => { Console.WriteLine(\"开始业务\"); throw new Exception(); return await Task.FromResult(\"正常返回值\"); }); Console.WriteLine(value); Fallback有很多重载，可根据不同策略灵活使用。如只处理异常信息中包含某些关键字异常。 await Policy .Handle(ex => ex.Message.Contains(\"haha\")) //故障 .FallbackAsync(async _ => Console.WriteLine(\"策略动作\")) .ExecuteAsync(async () => { Console.WriteLine(\"开始业务\"); throw new ArgumentException(\"haha\"); Console.WriteLine(\"结束业务\"); }); 3.1.2 重试 重试处理允许服务出现指定故障时按照策略进行重试。重试操作并不会处理异常，重试过程中会忽略异常，重试完成后会继续抛出异常。 await Policy .Handle() .RetryAsync(3) .ExecuteAsync(async () => { Console.WriteLine(\"开始任务\"); if (DateTime.Now.Second % 10 != 0) throw new Exception(\"出错\"); Console.WriteLine(\"完成任务\"); }); 方法 含义 Retry(n) 不指定n则默认重试一次 RetryForever() 一直重试直到成功 WaitAndRetry() 等待指定时间后重试。可实现“如果出错等待100ms再试还不行再等150ms秒等效果 WaitAndRetryForever 等待指定时间重试，直到成功 3.1.3 熔断 出现N次连续错误,则把“熔断器”(保险丝)熔断,等待一段时间,等待这段时间内如果再Execute则直接抛出BrokenCircuitException异常,而不再去尝试调用业务代码。等待时间过去之后,再执行Execute的时候如果又错了(一次就够了),那么继续熔断一段时间,否则就恢复正常。跟iPhone的屏幕解锁密码错误重试机制类似，不同的是这里等待时间是固定的。 这样就避免一个服务已经不可用了,还是疯狂的对其进行请求给系统造成更大压力。熔断操作并不会处理异常。 await Policy .Handle() .CircuitBreakerAsync(5, TimeSpan.FromSeconds(5)) //连续出错5次之后熔断5秒 .ExecuteAsync(async () => { //... 业务代码 throw new Exception(\"出错\"); }); 3.2 超时处理 Timeout 定义超时故障策略。Execute 超过指定时间后就会抛出 TimeoutRejectedException。用于处理请求网络接口,避免接口长期没有响应造成系统卡死等情况。 一般超时策略需要结合异常处理策略使用。 await Policy.TimeoutAsync(2, TimeoutStrategy.Pessimistic) .ExecuteAsync(async () => { Console.WriteLine(\"开始业务\"); //异步方法中使用Thread.Sleep()不会触发超时 await Task.Delay(3000); //将抛出 TimeoutRejectedException }); TimeoutStrategy指定超时处理方式，有悲观(Pessimistic)和乐观(Optimistic)两种处理方式。乐观处理会由系统决定如何进行后续操作，可能不会抛出超时异常，可控性较差，一般情况下多使用悲观方式。 3.3 组合策略 一般情况下我们会使用 Wrap 组合多种策略。Wrap方法组合策略顺序是由外而内，执行策略是由内而外。内层的故障如果没有被处理则会抛出到外层。 //重试策略 var policyRetry = Policy .Handle() .RetryAsync(5); //熔断策略 var policyCb = Policy .Handle() .CircuitBreakerAsync(3, TimeSpan.FromSeconds(5));//生产中熔断次数一般要大于重试策略次数，此处设定仅为测试策略顺序 //降级策略 var policyFb = Policy .Handle() .FallbackAsync( async _ => Console.WriteLine(\"异常处理\"), async ex => Console.WriteLine(ex.Message) ); //超时策略 var policyTimeout = Policy.TimeoutAsync(2, TimeoutStrategy.Pessimistic); //组合以上策略 var policy = Policy.WrapAsync(policyFb, policyRetry, policyCb, policyTimeout); await policy.ExecuteAsync(async () => { Console.WriteLine(\"开始业务\"); await Task.Delay(3000); Console.WriteLine(\"完成业务\");// 超时异常被处理后不会阻止后续执行 }); 上面代码策略组合发挥作用时顺序是 超时->熔断->重试->降级。代码执行到Thread.Sleep(3000)触发超时策略，抛出超时异常，异常会触发重试策略，重试策略忽略超时异常并重试执行，重试第三3次时会触发之前加入的熔断策略，抛出熔断异常，熔断异常则被外层的降级策略所捕捉处理，最终做降级处理。 一般情况下熔断策略设定的熔断次数要大于重试策略设定的重试次数，否则重试策略会被熔断。上面代码设定的熔断次数小于重试次数近为验证策略执行顺序。 4. 熔断降级框架 了解了Polly的基础知识之后，我们可以利用Polly来做服务的熔断降级处理，保证整体系统的稳定性。 我们可以在可能出现问题的API方法中使用Polly做相应的熔断降级处理，但直接使用 Polly,会造成业务代码中混杂大量的业务无关代码。 我们可以利用AOP思想，在需要做熔断降级处理的API方法上使用使用拦截器，API方法中只负责写业务代码，所有的熔断降级操作在拦截器中完成即可。这里可以直接使用一套开源的.NET平台的拦截器框架AspectCore。目前同时支持.NET Framework 4.5+和.NET Core。 4.1 AspectCore 我们简单演示一下AspectCore的使用。 1) 创建拦截器 创建自定义拦截器继承AbstractInterceptorAttribute，并重写Invoke方法。 public class MyInterceptorAttribute : AbstractInterceptorAttribute { //被拦截方法触发invoke方法 public override async Task Invoke(AspectContext context, AspectDelegate next) { try { Console.WriteLine(\"Before method call\"); await next(context); //执行被拦截的方法 } catch { Console.WriteLine(\"Method threw an exception!\"); } finally { Console.WriteLine(\"After method call\"); } } } 2) 使用拦截器 在需要拦截的方法上打上拦截器标记即可。AspectCore要求拦截器使用方法所在类必须是public修饰的并且方法必须标记为虚方法。因为其运行时会动态创建拦截器使用类的子类并重写拦截的方法，原理与EF的实体模型处理方式类似。 public class Person { [MyInterceptor] public virtual void SayHi(string name) { Console.WriteLine($\"Hi {name}\"); } } 3) 测试拦截器 using (var proxyGenerator = new ProxyGeneratorBuilder().Build()) { //创建代理类 var person = proxyGenerator.CreateClassProxy(); person.SayHi(\"Colin\"); } 这里不能new Person()对象,而必须使用生成器创建对象才能使拦截器产生效，因为拦截器通过动态创建子类来实现。 4.2 封装熔断降级框架 熟悉了以上拦截器工作原理，我们就可以在拦截器的Invoke方法中使用Polly实现熔断降级了。 这里我们就仿照Spring Cloud 中的 Hystrix 来封装一个简单的熔断降级框架。具体实现参阅 https://github.com/yangzhongke/RuPeng.HystrixCore 1) 创建拦截器 [AttributeUsage(AttributeTargets.Method)] public class HystrixCommandAttribute : AbstractInterceptorAttribute { /// /// 最多重试几次，如果为0则不重试 /// public int MaxRetryTimes { get; set; } = 0; /// /// 重试间隔的毫秒数 /// public int RetryIntervalMilliseconds { get; set; } = 100; /// /// 是否启用熔断 /// public bool EnableCircuitBreaker { get; set; } = false; /// /// 熔断前出现允许错误几次 /// public int ExceptionsAllowedBeforeBreaking { get; set; } = 3; /// /// 熔断多长时间（毫秒） /// public int MillisecondsOfBreak { get; set; } = 1000; /// /// 执行超过多少毫秒则认为超时（0表示不检测超时） /// public int TimeOutMilliseconds { get; set; } = 0; /// /// 缓存多少毫秒（0表示不缓存），用“类名+方法名+所有参数ToString拼接”做缓存Key /// public int CacheTtlMilliseconds { get; set; } = 0; private static ConcurrentDictionary policies = new ConcurrentDictionary(); private static readonly Microsoft.Extensions.Caching.Memory.IMemoryCache MemoryCache = new Microsoft.Extensions.Caching.Memory.MemoryCache( new Microsoft.Extensions.Caching.Memory.MemoryCacheOptions()); /// /// /// /// 降级的方法名 public HystrixCommandAttribute(string fallBackMethod) { FallBackMethod = fallBackMethod; } public string FallBackMethod { get; set; } public override async Task Invoke(AspectContext context, AspectDelegate next) { //一个HystrixCommand中保持一个policy对象即可 //其实主要是CircuitBreaker要求对于同一段代码要共享一个policy对象 //根据反射原理，同一个方法的MethodInfo是同一个对象，但是对象上取出来的HystrixCommandAttribute //每次获取的都是不同的对象，因此以MethodInfo为Key保存到policies中，确保一个方法对应一个policy实例 policies.TryGetValue(context.ServiceMethod, out var policy); lock (policies) //因为Invoke可能是并发调用，因此要确保policies赋值的线程安全 { if (policy == null) { policy = Policy.NoOpAsync(); //创建一个空的Policy if (EnableCircuitBreaker) { policy = policy.WrapAsync(Policy.Handle() .CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak))); } if (TimeOutMilliseconds > 0) { policy = policy.WrapAsync(Policy.TimeoutAsync( () => TimeSpan.FromMilliseconds(TimeOutMilliseconds), Polly.Timeout.TimeoutStrategy.Pessimistic)); } if (MaxRetryTimes > 0) { policy = policy.WrapAsync(Policy.Handle().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds))); } var policyFallBack = Policy .Handle() .FallbackAsync(async (ctx, t) => { var aspectContext = (AspectContext) ctx[\"aspectContext\"]; var fallBackMethod = context.ImplementationMethod.DeclaringType?.GetMethod(FallBackMethod); var fallBackResult = fallBackMethod?.Invoke(context.Implementation, context.Parameters); //不能如下这样，因为这是闭包相关，如果这样写第二次调用Invoke的时候context指向的 //还是第一次的对象，所以要通过Polly的上下文来传递AspectContext //context.ReturnValue = fallBackResult; aspectContext.ReturnValue = fallBackResult; await Task.CompletedTask; }, async (ex, t) => { //TODO:记录触发降级的异常信息 }); policy = policyFallBack.WrapAsync(policy); //放入 policies.TryAdd(context.ServiceMethod, policy); } } //把本地调用的AspectContext传递给Polly，主要给FallbackAsync中使用，避免闭包的坑 var pollyCtx = new Context {[\"aspectContext\"] = context}; //Install-Package Microsoft.Extensions.Caching.Memory if (CacheTtlMilliseconds > 0) { //用类名+方法名+参数的下划线连接起来作为缓存key var cacheKey = \"HystrixMethodCacheManager_Key_\" + context.ImplementationMethod.DeclaringType + \".\" + context.ImplementationMethod + string.Join(\"_\", context.Parameters); //尝试去缓存中获取。如果找到了，则直接用缓存中的值做返回值 if (MemoryCache.TryGetValue(cacheKey, out var cacheValue)) { context.ReturnValue = cacheValue; } else { //如果缓存中没有，则执行实际被拦截的方法 await policy.ExecuteAsync(ctx => next(context), pollyCtx); //存入缓存中 using (var cacheEntry = MemoryCache.CreateEntry(cacheKey)) { cacheEntry.Value = context.ReturnValue; cacheEntry.AbsoluteExpiration = DateTime.Now + TimeSpan.FromMilliseconds(CacheTtlMilliseconds); } } } else //如果没有启用缓存，就直接执行业务方法 { await policy.ExecuteAsync(ctx => next(context), pollyCtx); } } } 2) 使用拦截器 public class Person //需要public类 { [HystrixCommand(nameof(Hello1FallBackAsync), MaxRetryTimes = 3, EnableCircuitBreaker = true)] public virtual async Task HelloAsync(string name) //需要是虚方法 { Console.WriteLine(\"尝试执行HelloAsync\" + name); string s = null; s.ToString(); return \"ok\" + name; } [HystrixCommand(nameof(Hello2FallBackAsync))] public virtual async Task Hello1FallBackAsync(string name) { Console.WriteLine(\"Hello降级1\" + name); String s = null; s.ToString(); return \"fail_1\"; } public virtual async Task Hello2FallBackAsync(string name) { Console.WriteLine(\"Hello降级2\" + name); return \"fail_2\"; } [HystrixCommand(nameof(AddFall), EnableCircuitBreaker = true)] public virtual int Add(int i, int j) { string s = null; s.ToString(); return i + j; } public int AddFall(int i, int j) { Console.WriteLine($\"降级执行{nameof(AddFall)}\"); return 0; } [HystrixCommand(nameof(TestFallBackAsync), TimeOutMilliseconds = 1000)] public virtual async Task TestAsync(int i) { Console.WriteLine(\"Test\" + i); await Task.Delay(2000); } public async virtual Task TestFallBackAsync(int i) { Console.WriteLine(\"超时降级\"); } } 3) 测试拦截器 using (var proxyGenerator = new ProxyGeneratorBuilder().Build()) { var p = proxyGenerator.CreateClassProxy(); //降级测试 Console.WriteLine(p.Add(1, 2)); //重试，连续降级测试 Console.WriteLine(await p.HelloAsync(\"Colin\")); //熔断测试 while (true) { Console.WriteLine(p.Add(1, 2)); await Task.Delay(500); } //超时测试 await p.TestAsync(1); } 4.3 熔断框架依赖注入 经过以上封装之后我们就可以方便的对API方法使用Polly熔断降级框架了。然而每次都要使用ProxyGenerator来创建对象依然比较繁琐,我们可以使用依赖注入来解决这些问题。 借助依赖注入,可以简化代理类对象的创建,不用再自己调用 ProxyGenerator 进行代理类对象创建。AspectCore为我们提供了AspectCore.Extensions.DependencyInjection扩展来实现DI。 public interface IPerson { // 仅声明业务方法 string SayHi(string name); } public class Person : IPerson { // 业务实现 [HystrixCommand(nameof(SayHiFallback))] public virtual string SayHi(string name) { return $\"Hi {name.ToUpper()}\"; } // 降级处理 public string SayHiFallback(string name) { return $\"Hi new friend\"; } } // 返回值从 void 改为 IServiceProvider public IServiceProvider ConfigureServices(IServiceCollection services) { services.AddSingleton(); //注册\"熔断处理\"过的安全服务 return services.BuildAspectInjectorProvider(); //让aspectcore接管DI } AspectCore拦截器只能在ProxyGenerator创建的代理类中起作用，而WebAPI中Controller的创建是Asp.Net Core框架来负责的,所以在API接口中使用熔断拦截器无效。通常的做法是在API接口中接收用户请，然后交给业务逻辑层来处理，业务逻辑层对象则是由AspectCore的创建并注入到接口层的所以可以在业务逻辑层中启用熔断拦截器。 [Route(\"api/[controller]\")] public class TestController : ControllerBase { private readonly IPerson _person; public TestController(IPerson person) { _person = person; } [HttpGet(\"{name?}\")] public ActionResult Get(string name) { return _person.SayHi(name); } } 每个\"熔断处理\"过的服务都要在ConfigureServices中注入，如果服务表数量较多，每次手动注入比较繁琐，而这些服务一般都在业务逻辑层中，我们可以自定义一个方法来反射遍历业务逻辑层程序集中使用了熔断拦截器的服务对象进行一次性注入。 public IServiceProvider ConfigureServices(IServiceCollection services) { RegisterServices(services, Assembly.Load(\"Xiaoyang.TemplateService.Bll.Implement\"));// Bll程序集中所有熔断处理的服务一次性注入 return services.BuildAspectInjectorProvider(); //让aspectcore接管DI } // 注册\"熔断安全\"服务 private void RegisterServices(IServiceCollection services, Assembly assembly, bool hystrixOnly = true) { foreach (var type in assembly.GetExportedTypes()) { //要求业务实现类的第一个接口实现必须是其业务接口。可以实际情况自行约定规则。 var interfaceType = type.GetInterfaces().FirstOrDefault(); if (interfaceType == null) continue; if (hystrixOnly) { var hasHystrix = type.GetMethods() .Any(m => m.GetCustomAttribute(typeof(HystrixCommandAttribute)) != null); if (!hasHystrix) continue; } services.AddSingleton(interfaceType, type); } } © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/microservice-ocelot.html":{"url":"pages/microservice-ocelot.html","title":"2.4 网关","keywords":"","body":"API 网关 1. API GateWay 原则上微服务体系中所有在注册中心注册的服务都属于内部服务，不对用户直接开放，生产环境中这些服务多部署于一个局域网中，不能被外网直接访问到。 实际应用中我们常需要开放一些服务给用户，比如用户通过手机端或Web端请求文件服务器以加载资源文件，Web用户端直接请求Web应用服务器等。那对于客户端这些请求，我们不可能直接开放所有的服务，客户端记忆所有的服务地址和端口也非常繁琐，一旦服务端配置发生变化，可能会导致客户端无法正常工作，增强了系统之间耦合度。如果服务需要授权访问或者进行限流收费等，那每个服务都需要提供以上功能也导致重复工作。 API网关就是为了解决以上这些问题。API网关的角色是作为客户端访问服务的统一入口。所有用户请求都首先经过API网关，然后再转发给具体服务。正是“一夫当关”的位置，也在一定程度上体现了AOP的思想。我们可以在网关中进行统一的认证授权、限流收费等。 .Net微服务体系中目前比较流行的API网管是Ocelot，Nginx进行定制后也可以作为网关使用。 官网:https://github.com/ThreeMammals/Ocelot 资料:http://www.csharpkit.com/apigateway.html Ocelot 中文文档:http://www.jessetalk.cn/2018/03/19/net-core-apigateway-ocelot-docs/ 2. Ocelot 基本使用 Ocelot 就是一个提供了请求路由、安全验证等功能的 API 网关微服务。在Asp.Net Core中一般表现为一个WebAPI项目，但是我们不需要MVC功能，所以删除MVC服务和中间件以及Controller。 2.1 基本使用 1) 配置文件 Ocelot使用方式比较简单，基本不需要Coding，只要按照其语法规范定义和修改配置文件即可。通过配置文件可以完成对Ocelot的功能配置：路由、服务聚合、服务发现、认证、鉴权、限流、熔断、缓存、Header头传递等。 以下是最基本的配置信息，在配置文件中包含两个根节点：ReRoutes和GlobalConfiguration。 { \"ReRoutes\": [], \"GlobalConfiguration\": { \"BaseUrl\": \"https://api.mybusiness.com\" } } 要特别注意一下BaseUrl是我们外部暴露的Url。 2) 配置依赖注入与中间件 public void ConfigureServices(IServiceCollection services) { services.AddOcelot(); } public async void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } await app.UseOcelot(); } 2.1 路由 Ocelot的最基本的功能就是路由，也就是请求转发。路由规则定义在ReRoutes配置节点中，ReRoutes是一个数组，其中的每一个元素代表了一个路由。 \"ReRoutes\": [ { \"DownstreamPathTemplate\": \"/api/test/{url}\", \"DownstreamScheme\": \"http\", \"DownstreamHostAndPorts\": [ { \"Host\": \"localhost\", \"Port\": 8000 } ], \"UpstreamPathTemplate\": \"/test/{url}\", \"UpstreamHttpMethod\": [ \"Get\", \"Post\" ] } ] 以上路由规则会将会对该Ocelot服务器的/test/{url}请求转发给http://localhost:8000/api/test/{url}。允许Get和Post请求 配置项 含义 Downstream 下游服务配置 UpStream 上游服务配置 Aggregates 服务聚合配置 ServiceName, LoadBalancer, UseServiceDiscovery 配置服务发现 AuthenticationOptions 配置服务认证 RouteClaimsRequirement 配置Claims鉴权 RateLimitOptions 限流配置 FileCacheOptions 缓存配置 QosOptions 服务质量与熔断 DownstreamHeaderTransform Headers信息转发 2.1.1 万能模板 上游Host也是路由用来判断的条件之一，由客户端访问时的Host来进行区别。比如当a.jesetalk.cn/users/{userid}和b.jessetalk.cn/users/{userid}两个请求的时候可以进行区别对待。 { \"UpstreamPathTemplate\": \"/\", \"UpstreamHttpMethod\": [ \"Get\" ], \"UpstreamHost\": \"ccstudio.org\", \"DownstreamPathTemplate\": \"/\", \"DownstreamScheme\": \"https\", \"DownstreamHostAndPorts\": [ { \"Host\": \"10.0.10.1\", \"Port\": 80, } ] } 2.1.2 优先级 对多个产生冲突的路由设置Prioirty。 { \"UpstreamPathTemplate\": \"/goods/{catchAll}\" \"Priority\": 0 } { \"UpstreamPathTemplate\": \"/goods/delete\" \"Priority\": 1 } 当请求/goods/delete的时候，则下面那个会生效。也就是说Prority是大的会被优先选择。 2.2 负载均衡 当下游服务有多个结点的时候，我们可以在DownstreamHostAndPorts中进行配置。通常也结合Consul来实现负载均衡。 { \"DownstreamPathTemplate\": \"/api/posts/{postId}\", \"DownstreamScheme\": \"https\", \"DownstreamHostAndPorts\": [ { \"Host\": \"10.0.1.10\", \"Port\": 5000, }, { \"Host\": \"10.0.1.11\", \"Port\": 5000, } ], \"UpstreamPathTemplate\": \"/posts/{postId}\", \"LoadBalancer\": \"LeastConnection\", \"UpstreamHttpMethod\": [ \"Put\", \"Delete\" ] } LoadBalancer将决定负载均衡的算法。 负载方式 含义 LeastConnection 将请求发往最空闲的那个服务器 RoundRobin 轮流发送 NoLoadBalance 总是发往第一个请求或者是服务发现 2.3 Work with Consul 上面的案例中转发规则是硬编码的，我们知道实际下游服务之间访问都是通过注册中心来映射的，Ocelet也可以完美的和Consul一起合作。 以下用法基于Consul v1.4.3和Ocelot 13.0.0，如果更新版本方法不可用，请参与官方文档。 添加Consul服务提供程序 dotnet add package Ocelot.Provider.Consul 注册Consul服务 public void configureservices(iservicecollection services) { services.AddOcelot().AddConsul(); } 修改配置文件如下 \"ReRoutes\": [ { \"UpstreamPathTemplate\": \"/test/{url}\", \"UpstreamHttpMethod\": [ \"Get\", \"Post\" ], \"DownstreamPathTemplate\": \"/api/test/{url}\", \"DownstreamScheme\": \"http\", \"ServiceName\": \"Xiaoyang.TemplateService\", \"LoadBalancerOptions\": { \"Type\": \"LeastConnection\" }, \"UseServiceDiscovery\": true } ], \"GlobalConfiguration\": { \"ServiceDiscoveryProvider\": { \"Host\": \"localhost\", \"Port\": 8500, \"Type\": \"Consul\" }, \"BaseUrl\": \"http://localhost:5000\" } 以上路由规则会将对该 Ocelot 服务器的/test/{url}请求按照最少连接优先的负载均衡策略转发给下游应用服务群，转发格路径格式为/api/test/{url}，服务发现与健康检查工作交由地址为http://localhost:8500的Consul注册中心处理。BaseUrl为当前Ocelot服务地址。 3. 其他功能 3.1 限流 3.2 QOS(熔断器) 3.3 请求缓存 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/rpc.html":{"url":"pages/rpc.html","title":"2.6 RPC","keywords":"","body":"RPC 1. RPC 2. Thrift 2.1 简介 2.2 工作原理 2.3 .Net 使用 3. 案例源码 1. RPC RPC(Remote Procedure Call Protocol) - 远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。 单体程序中可以直接调用自身服务方法，但在分布式系统当中，如何实现服务调用呢，RPC技术简单说就是为了解决远程调用服务的一种技术，使得调用者像调用本地服务一样方便透明。 RPC可以采用HTTP协议，并且使用最为广泛，优点是开放、标准、简单、兼容性升级容易，缺点是性能略低。在 QPS 较高或者对响应时间要求苛刻的情况下,常采用二进制传输、如TCP通讯,更加高效也更加安全。也有部分公司采用私有协议，如腾讯的JCE协议。RPC 虽然效率略高,但是耦合性强,如果兼容性处理不好的话,一旦服务器端接口升级,客户端就要同步更新,没有HTTP灵活。 RPC在各大互联网公司中被广泛使用，如阿里巴巴的hsf、dubbo（开源）、Facebook的thrift（开源）、Google gRPC（开源）、Twitter的finagle（开源）等。 .Net Core中常用的RPC框架有 gRPC、Thrift 等, gRPC、Thrift 等都支持主流的编程语言。 性能方面：Thirft(大约 10 倍) > gRPC > Http。数据涞源于互联网,性能和业务数据的特点有关,仅供参考。 最佳实践：对内一些性能要求高的场合用 RPC,对内其他场合以及对外采用HTTP。 2. Thrift 2.1 简介 Thrift是一种接口描述语言和二进制通讯协议，是由Facebook为“大规模跨语言服务开发”而开发的。它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的跨平台高效服务，可以使用C#、C++（基于POSIX兼容系统）、Cappuccino、Cocoa、Delphi、Erlang、Go、Haskell、Java、Node.js、OCaml、Perl、PHP、Python、Ruby和Smalltalk。现在是Apache软件基金会的开源项目。 2.2 工作原理 Thrif通过模版文件定义服务接口规范，模版文件可以生成不同语言平台的代码文件，服务端和客户端分别引用生成的接口文件，服务端实现接口内容，并Host服务公开通讯地址，客户端连接服务端地址，并按照接口规范调用服务即可。 由于Thrif需要兼容大多数主流语言平台，所以接口文档不能采用所有语言各自书写一遍，于是Thrif推出 IDL(interface definition language)来书写接口文档。IDL仅用于定义接口，包含常用的数据类型，语法比价简单，具体语法使用可以参阅 https://www.cnblogs.com/valor-xh/p/6386584.html 2.3 .Net 使用 下面我们以.Net Core为例简单演示一下Thrif的使用。Thrif 官方也提供了常用开发语言的案例，参见 https://github.com/colin-chang/thrift-official 1) 定义模板 创建模板文件 UserService.thrift。模板文件扩展名通常为.thrift namespace csharp ThriftDemo.Contract.Net namespace netcore ThriftDemo.Contract.Core service UserService { bool Create(1: Person person) bool Delete(1: i32 id) void Update(1: Person person) Person Query(1: i32 id) } struct Person { 1: i32 id 2: string name 3: i32 age } 2) 生成接口文档 Thrift提供了不同平台的模板生成程序Windows下是一个可执行程序使用比较简单，但在mac OS和Linux下使用生成器则需要安装复杂的运行环境，但是Docker让一切变得无比简单，这里给出Docker生成器使用命令。 # .NET sync docker run --rm -v \"$PWD:/data\" thrift thrift -o /data --gen csharp /data/UserService.thrift # .Net Core async docker run --rm -v \"$PWD:/data\" thrift thrift -o /data --gen netcore /data/UserService.thrift 目前 Thrift v0.13.0 为.Net Core提供了TPL风格代码，支持异步，但遗憾的是.Net Framework只有同步版本,两者代码实现也略有不同。 3) 创建接口项目 创建.Net Standard类库项目ThriftTemplate.Contract作为接口项目。 将上一步生成的接口文件拷贝到当前项目中。 引用 ApacheThrift nuget包到项目中 4) 服务端 1. 接口实现 创建类库项目ThriftTemplate.Contract.Implement 添加ThriftTemplate.Contract接口项目引用 实现接口。参考代码如下。 public class UserSvs : UserService.IAsync { public Task CreateAsync(Person person, CancellationToken cancellationToken) { // your code return Task.FromResult(true); } public Task DeleteAsync(int id, CancellationToken cancellationToken) { // your code return Task.FromResult(true); } public Task UpdateAsync(Person person, CancellationToken cancellationToken) { // your code return Task.CompletedTask; } public Task QueryAsync(int id, CancellationToken cancellationToken) { // your code return Task.FromResult(new Person {Id = 0, Name = \"Colin\", Age = 18}); } } 2. 运行服务 创建服务宿主控制台项目ThriftTemplate.Server。 管理项目引用 引用Nuget ApacheThrift Microsoft.Extensions.Logging 添加项目引用 接口项目ThriftTemplate.Contract 接口实现项目ThriftTemplate.Contract.Implement 启动服务到指定地址。参考代码如下。 var serviceProvider = new ServiceCollection() .AddSingleton(new UserSvs()) .AddLogging(logging => logging.SetMinimumLevel(LogLevel.Trace)) .BuildServiceProvider(); using (var source = new CancellationTokenSource()) { var server = new AsyncBaseServer( new AsyncProcessor(serviceProvider.GetService()), new TServerSocketTransport(10010),//监听端口 new TBinaryProtocol.Factory(), new TBinaryProtocol.Factory(), serviceProvider.GetService() ); await server.ServeAsync(source.Token); } 5) 客户端 创建客户端控制台项目ThriftTemplate.Client 添加ThriftTemplate.Contract接口项目引用。引用 ApacheThrift 调用远程服务。参考代码如下。//创建服务连接 using (var transport = new TSocketClientTransport(IPAddress.Parse(\"127.0.0.1\"), 10010)) { using (var protocol = new TBinaryProtocol(transport)) { using (var client = new UserService.Client(protocol)) { using (var source = new CancellationTokenSource()) { await client.OpenTransportAsync(source.Token); await client.QueryAsync(0, source.Token);//调用服务方法 } } } } 6) 项目优化 以上我们可以发现，客户端调用每个服务端方法都需写类似调用代码较繁琐且重复，于是我们考虑将封装扩展对服务端方法调用，我们发现Thrift生成的接口文件中，接口的所在类都是partial class就是为了方便开发者自行扩展且避免重新生成后造成代码覆盖丢失。 每个接口方法都需要提供一个帮助扩展方法，于是我们可以考虑直接实现服务接口，同时为了方便使用我们也可以将服务运行代码进行封装。 我们在接口项目ThriftTemplate.Contract中新建UserServiceExtension.cs并对服务接口调用做如下扩展。 public partial class UserService : UserService.IAsync { // 服务端 public static async Task RunAsync(IAsync processor, int port, ILoggerFactory loggerFactory) { using (var source = new CancellationTokenSource()) { var server = new AsyncBaseServer( new AsyncProcessor(processor), new TServerSocketTransport(port), new TBinaryProtocol.Factory(), new TBinaryProtocol.Factory(), loggerFactory ); await server.ServeAsync(source.Token); } } private readonly IPAddress _host; private readonly int _port; public UserService(IPAddress host, int port) { _host = host; _port = port; } //以下为客户端扩展 public async Task CreateAsync(Person person) { using (var source = new CancellationTokenSource()) return await CreateAsync(person, source.Token); } public async Task CreateAsync(Person person, CancellationToken cancellationToken) => await InvokeAsync(async client => await client.CreateAsync(person, cancellationToken), cancellationToken); public async Task DeleteAsync(int id) { using (var source = new CancellationTokenSource()) return await DeleteAsync(id, source.Token); } public async Task DeleteAsync(int id, CancellationToken cancellationToken) => await InvokeAsync(async client => await client.DeleteAsync(id, cancellationToken), cancellationToken); public async Task UpdateAsync(Person person) { using (var source = new CancellationTokenSource()) await UpdateAsync(person, source.Token); } public async Task UpdateAsync(Person person, CancellationToken cancellationToken) => await InvokeAsync(async client => await client.UpdateAsync(person, cancellationToken), cancellationToken); public async Task QueryAsync(int id) { using (var source = new CancellationTokenSource()) return await QueryAsync(id, source.Token); } public async Task QueryAsync(int id, CancellationToken cancellationToken) => await InvokeAsync(async client => await client.QueryAsync(id, cancellationToken), cancellationToken); private async Task InvokeAsync(Action action, CancellationToken cancellationToken) { using (var transport = new TSocketClientTransport(_host, _port)) { using (var protocol = new TBinaryProtocol(transport)) { using (var client = new Client(protocol)) { await client.OpenTransportAsync(cancellationToken); action(client); } } } } private async Task InvokeAsync(Func> action, CancellationToken cancellationToken) { using (var transport = new TSocketClientTransport(_host, _port)) { using (var protocol = new TBinaryProtocol(transport)) { using (var client = new Client(protocol)) { await client.OpenTransportAsync(cancellationToken); return await action(client); } } } } } 使用以上扩展后，服务端和客户端代码可以大大简化。 //服务端 var serviceProvider = new ServiceCollection() .AddSingleton(new UserSvs()) .AddLogging(logging => logging.SetMinimumLevel(LogLevel.Trace)) .BuildServiceProvider(); await UserService.RunAsync(serviceProvider.GetService(), 10010, serviceProvider.GetService()); //客户端 var service = new UserService(IPAddress.Parse(\"127.0.0.1\"), 10010); await service.QueryAsync(0); await Service.DeleteAsync(0); 7) .Net Framework与.Net Core ApacheThrift是Apach官方提供的Provider，可以兼容.Net Core和.Net Framework，它为.Net Core和.Net Framework提供了不同的dll，所以也导致使用此package的.Net Core和.Net Framework项目不可互通，如，不能使用一个 .net core客户端调用.net framework服务端。 如果需要实现.Net Framework和.Net Core的Thrift互通可以是使用第三方nuget包，如apache-thrift-netcore，它可以兼容所有.net实现。 3. 案例源码 Core目录下是.Net Core版本实现。 Net目录下是.Net Framework版本实现。 Cross目录下是.Net Core与.Net Framework混用版本 项目案例下载：https://github.com/colin-chang/ThriftTemplate 参考文档 https://www.cnblogs.com/focus-lei/p/8889389.html http://doc.oschina.net/grpc?t=58008 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/microservice-docker.html":{"url":"pages/microservice-docker.html","title":"2.7 Docker+微服务","keywords":"","body":"微服务容器化实践 1. 微服务架构实践 Nginx放在什么位置？ 负载均衡 -> 网关集群 -> 注册中心集群 -> 应用服务集群 -> 数据库服务 Docker容器化后的微服务如何通讯？ 使用SingalR后如何反推消息 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/multithreading-intro.html":{"url":"pages/multithreading-intro.html","title":"1.1 进程、线程和应用程序域","keywords":"","body":"进程、线程和应用程序域 1. 进程 进程(Process)是操作系统中的一个基本概念，它包含着一个运行程序所需要的资源。进程之间是相对独立的，一个进程无法直接访问另 一个进程的数据（除非利用分布式计算方式），一个进程运行的失败也不会影响其他进程的运行，操作系统就是利用进程把工作划分为多个独立的区域的。进程可以理解为一个程序的基本边界。 操作系统分配资源的最小单位是进程，进程之间是相互隔离的，即每个进程有属于自己的数据段、程序段、进程控制块。 2. 线程 线程(Thread)是任务调度的最小单位。一个线程是一个进程里面的代码执行流，每个线程都有自己的专有寄存器(栈指针、程序计数器等)，但代码区是共享的。 3. 应用程序域 应用程序域(App Domain)提供安全而通用的处理单元，公共语言运行库可使用它来提供应用程序之间的隔离。我们可以单个进程中运行几个应用程序域，而不会造成进程间调用或进程间切换等方面的额外开销。在一个进程内运行多个应用程序的能力显著增强了服务器的可伸缩性。 应用程序域允许我们在一个应用程序中出现的错误不会影响其他应用程序。能够在不停止整个进程的情况下停止单个应用程序。应用程序域形成了托管代码的隔离、卸载和安全边界。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/multithreading-basic.html":{"url":"pages/multithreading-basic.html","title":"1.2 进程、线程基础","keywords":"","body":"进程、线程基础 1. 进程管理 .NET中使用Process类管理维护进程信息。Process常用成员如下。 成员 含义 Threads 获取当前进程的所有线程 Kill() 杀掉指定进程 Process.GetCurrentProcess() 拿到当前程序进程 Process.GetProcesses() 拿到系统当前所有进程 Process.GetProcessById() 拿到指定Id的进程 Process.Start() 启动一个进程。 // 启动IE浏览器并访问百度 Process.Start(\"iexplore\",\"https://www.baidu.com\"); 2. 线程基础 多线程可以让一个程序“同时”处理多个事情。后台运行程序，提高程序的运行效率，同时解决耗时操作时GUI出现无响应的情况。 一个进程的多个线程之间可以共享程序代码。每个线程会将共享的代码分别拷贝一份去执行，每个线程是单独执行的。 线程有前台线程和后台线程，创建一个线程默认为前台线程。 只有所有的前台线程都关闭时程序才能退出。只要所有前台线程都关闭后台线程自动关闭。 线程被释放时，线程中定义的内容都会自动被释放 .NET中使用Thread类管理维护线程信息。Thread常用成员如下。 成员 含义 Name 线程名 IsBackground 获取或设置是否是后台线程 IsAlive 表示当前线程的执行状态 ManagedThreadId 获取当前托管线程的唯一标示符Id Priority 获取或设置线程的优先级，只是推荐给OS，并不一定执行 Start() 启动线程 Interrupt() 用于提前唤醒一个在Sleep的线程 Abort() 强制终止线程 Join() 等待指定线程执行完毕后再接着执行当前线程 Thread.CurrentThread 获得当前的线程引用 Thread.Sleep() 让当前线程休眠。只能当前线程自身主动休眠，不能被其他线程控制。 Abort()方法会引发线程内当前在执行的代码抛出ThreadAbortException，可能会造成线程占用资源无法释放，一般情况下不推荐使用。可以通过结束线程执行的方法来结束并释放线程。 Interrupt()唤醒Sleep的线程时Sleep方法会抛出 ThreadInterruptedException，需要我们catch异常，否则异常会导致程序崩溃退出。 var t1 = new Thread(() => { try { Thread.Sleep(5000); } catch (ThreadInterruptedException) { Console.WriteLine(\"t1线程被意外唤醒\"); } Console.WriteLine(\"Fuck\"); }) {IsBackground = true}; t1.Start(); t1.Interrupt(); © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/multithreading-synchronization.html":{"url":"pages/multithreading-synchronization.html","title":"1.3 线程同步","keywords":"","body":"线程同步 1. 线程同步 1.1 Join 1.2 MethodImplAttribute 1.3 对象互斥锁 1.4 多线程版单例模式 2. 生产者消费者模式 3. WaitHandle 3.1 ManualResetEvent 3.2 AutoResetEvent 1. 线程同步 当一个方法同时被多个线程调用并修改同一变量时就可能存在脏数据的问题，我们称之为“多线程方法重入”。我们可以通过以下方式来解决此问题。 1.1 Join Join()方法可以让当前线程等待指定线程执行结束后再接着运行当前线程。 var t1 = new Thread(() => { for (int i = 0; i { t1.Join(); //等着 t1 执行结束后接着执行以下代码 for (int i = 0; i 1.2 MethodImplAttribute 在线程不安全的方法上打上[MethodImpl(MethodImplOptions.Synchronized)]标记后，此方法同时只能被一个线程调用，变成了同步方法。 [MethodImpl(MethodImplOptions.Synchronized)] public void Count() { // do something ... } 1.3 对象互斥锁 var locker = new object(); public void Count() { lock (locker) { // do something ... } } 同一时刻只能有一个线程进入同一个对象的 lock 代码块。必须是同一个对象才能起到 互斥的作用。lock 后必须是引用类型,不一定是 object,只要是对象就行。 锁对象选择很重要,选不对起不到同步的作用和可能会造成其他地方被锁,比如用字符串做锁(因为字符串拘留池导致可能用的是其他地方也在用的锁)。 lock是对Monitor类的简化调用，此处我们就不在讲Monitor的相关使用了。 1.4 多线程版单例模式 class God { private static God _instance = null; private static readonly object Locker = new object(); private God(){} public static God GetInstance() { if (_instance == null) { lock (Locker) { if (_instance == null) _instance = new God(); } } return _instance; } } 以上方式保证线程安全，但是书写较为繁琐，日常开发中推荐使用静态单例方式。 class God { private God(){} private static readonly God Instance = new God(); public static God GetInstance() => Instance; } 2. 生产者消费者模式 多个线程同时修改共享数据可能会发生错误，此时我们常用生产者消费者模式来处理此问题。 在生成者和消费者关系中，生产者线程负责产生数据，并把数据存到公共数据区，消费者线程使用数据，从公共数据去中取出数据。我们使用资源加锁的方式来解决线程并发引起的方法重入问题。 class Program { static void Main(string[] args) { List list = new List();//创建产品池 //创建5个生产者 for (int i = 0; i { while (true) lock (list)//锁定对象解决线程并发引起的方法重入问题 { //生产一个产品 list.Add(new Product()); Console.WriteLine(\"生产产品{0}\", list.Count - 1); Thread.Sleep(500); } }) { IsBackground = true }.Start(); } //创建10个消费者 for (int i = 0; i { while (true) lock (list) { if (list.Count > 0) { //消费一个产品 list.RemoveAt(list.Count - 1); Console.WriteLine(\"消费产品{0}\", list.Count); Thread.Sleep(200); } } }) { IsBackground = true }.Start(); } Console.ReadKey(); } } class Product {} 3. WaitHandle 除了前面提到的“锁”机制外，.NET中WaitHandle还提供了一些线程间协同的方法，使得线程可以通过“信号”进行通讯。 WaitHandle是一个抽象类，EventWaitHandle是其实现类，我们常用EventWaitHandle两个子类ManualResetEvent和AutoResetEvent。 信号通讯在EventWaitHandle中被通俗的比喻为“门”，主要体现为以下三个方法： Set(); // 开门 WaitOne(); // 等待开门 Reset(); // 关门 等待开门除了WaitOne()之外还有以下用法。 //等待所有信号都变为“开门状态” WaitHandle.WaitAll(WaitHandle[] waitHandles); //等待任意一个信号变为“开门状态” WaitHandle.WaitAny(WaitHandle[] waitHandles); 3.1 ManualResetEvent ManualResetEvent被比喻为手动门，一旦开门后就保持开门状态，除非手动关门，如同“城门”。 var mre = new ManualResetEvent(false); //创建\"手动门\"，默认状态为\"关门\" new Thread(() => { mre.WaitOne(); //等待开门。开门之后后续代码方可执行，否则该线程一直阻塞在此处 Console.WriteLine(\"开门了...\"); while (true) { Console.WriteLine(DateTime.Now); Thread.Sleep(1000); } }){IsBackground = true}.Start(); Console.WriteLine(\"按任意键开门...\"); Console.ReadKey(); mre.Set(); //开门 Thread.Sleep(5000); mre.Reset(); //关门 Console.WriteLine(\"关门了...\"); WaitOne(5000); //最长等待5s。 3.2 AutoResetEvent AutoResetEvent被比喻为自动门，一次开门完成后自动关门，如同“地铁的闸机口”。 var are = new AutoResetEvent(false); //创建\"手动门\"，默认状态为\"关门\" new Thread(() => { are.WaitOne(); //等待开门。开门之后后续代码方可执行，否则该线程一直阻塞在此处 Console.WriteLine(\"开门了...\"); //do something ... }){IsBackground = true}.Start(); Console.WriteLine(\"按任意键开门...\"); Console.ReadKey(); are.Set(); //开门 WaitHandle现在.NET中较少使用了，但它们更多作为简单易用的多线程语法的底层实现。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/multithreading-threadpool.html":{"url":"pages/multithreading-threadpool.html","title":"1.4 线程池","keywords":"","body":"线程池 1 线程池简介 系统中创建一个线程就会开辟一个至少 1M 的内存空间 线程还可能会占用部分寄存器 线程非常多的时候,OS需要花费大量的时间在不同的线程之间进行切换。 我们可以通过线程池对以上问题进行优化。线程池是一组已经创建好的线程,随用随取,用完了不是销毁线程,然后放到线程池中,供其他人用。当需要创建大量线程时,我们推荐使用线程池技术。 系统同时处理的线程的个数与系统的硬件资源有关,线程数量与系统运行效率大概呈正态分布。在达到最高值之后,线程数量再增加 OS 将花费大量的时间和资源来切换线程,执行效率反而会下降。 2. 线程池特点 2.1 线程池特点 线程池线程本身默认都是后台线程，不需要手动启动 线程池中的线程可以进行重用，线程使用完成后不会马上释放而是进入线程池等待重用 当程序中需要创建大量线程执行小数据量操作时，线程池可以大幅调高线程执行效率。 使用线程池操作线程的灵活性较差，我们无法获取线程池中的线程信息，所以无法干预线程池中的线程 虽然工作项进入线程池队列的时候保证了先进先出，但是各个工作线程获取工作项放到本地的队列后是使用的先进后出的方式，所以不能保证整体的请求项之间是请求处理的顺序。 线程池有最大线程数，最小线程数和默认线程数。ThreadPool.GetMaxThreads()获取线程池的最大线程数和当前线程池大小，线程池大小会根据CPU自动计算获得，不推荐手动修改。ThreadPool.GetMinThreads()，获取线程池最小线程数 线程池提高了线程的利用率，非常适合工作任务非常小，而且又需要使用单独的线程来解决的问题。 2.2 手动创建线程与线程池对比 能用线程池的就用线程池，但线程池处理顺序不确定 线程池的优势在于线程执行大量小运算 要手动干预线程的话必须手动创建线程 要设置线程的优先级时，必须手动创建线程 线程执行时间较长是，两种方式差异不大 2.3 使用方式 //有参 ThreadPool.QueueUserWorkItem((s) => Console.WriteLine(s),\"Hello\"); //参数 ThreadPool.QueueUserWorkItem(s => Console.WriteLine(\"Hello\")); © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/multithreading-uiresource.html":{"url":"pages/multithreading-uiresource.html","title":"1.5 UI资源跨线程访问","keywords":"","body":"UI资源跨线程调用 在WinForm或WPF程序中，默认只允许在创建控件的线程(一般为UI线程)中访问控件，如果想在其他线程中访问UI资源，需要做特殊处理。 1. WPF Window类有一个Dispatcher对象，该对象是一个队列，用来保存应用程序主线程需要执行的任务。其他线程需要访问UI资源时只需要将操作加入到Dispatcher中，然后由主线程负责代为执行。 private void Button_Click(object sender, RoutedEventArgs e) { new Thread(() => ChangeText()).Start(); } private void ChangeText() { Random rdm = new Random(); string num = rdm.Next().ToString(); //当前线程不是主线程 if (Dispatcher.Thread != Thread.CurrentThread) { Dispatcher.Invoke(new Action(s => txt.Text = s), num); } //当前线程是主线程 else txt.Text = num; } 2. WinForm WinForm当中，我们有两种方式来解决UI资源跨线程访问的问题。 在Form构造函数中设置CheckForIllegalCrossThreadCalls = false，禁止窗体进行非法跨线程调用的校验，这只是屏蔽了非法校验，并没有真正解决问题，不推荐使用。 推荐使用以下方式： private void button1_Click(object sender, EventArgs e) { new Thread(() => ChangeText()).Start(); } private void ChangeText() { Random rdm = new Random(); string num = rdm.Next().ToString(); //当前线程是创建此控件的线程 if (txt.InvokeRequired) txt.Invoke(new Action(s => txt.Text = s), num); //当前线程不是创建此控件的线程 else txt.Text = num; } © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/multithreading-async.html":{"url":"pages/multithreading-async.html","title":"1.6 异步编程模型","keywords":"","body":"异步编程模型 1. EAP 2. APM 2.1 简单使用 2.2 同步调用 2.3 委托异步调用 3. TPL 3.1 简单使用 3.2 同步调用 3.3 并行异步 3.4 自定义异步方法 3.5 异常处理 .Net 中很多的类接口设计的时候都考虑了多线程问题,简化了多线程程序的开发。不用自己去写WaitHandler等这些底层的代码。随着历史的发展,这些类的接口设计演化经历过三种不同的风格:EAP、APM和TPL。 1. EAP EAP是Event-based Asynchronous Pattern(基于事件的异步模型)的简写。 // 注：WebClient类在.Net Core中不被支持，推荐使用HttpClient替代 var wc = new WebClient(); wc.DownloadStringCompleted += (s,e)=>{ MessageBox.Show(e.Result); }; wc.DownloadStringAsync(new Uri(\"https://www.baidu.com\")); EAP特点是一个异步方法配一个***Completed事件。使用简单，但业务复杂的时比较麻烦,比如下载 A 成功后再下载 B,如果下载 B 成功再下载 C,否则就下载 D,会出现类似JS的多层回调函数嵌套的问题。 2. APM APM是Asynchronous Programming Model(异步编程模型)的缩写。是.Net 旧版本中广泛使用的异步编程模型。 APM方法名字以 BeginXXX 开头,调用结束后需要 EndXXX回收资源。 .Net 中有如下的常用类支持APM:Stream、SqlCommand、Socket 等。 2.1 简单使用 //异步非阻塞方式 var fs = File.OpenRead(\"/Users/zhangcheng/test.txt\"); var buffer = new byte[10 * 1024]; fs.BeginRead(buffer, 0, buffer.Length, ar => { using (fs) { fs.EndRead(ar); Console.WriteLine(Encoding.UTF8.GetString(buffer)); } }, fs); 2.2 同步调用 APM方法名字以 BeginXXX 开头,返回类型为IAsyncResult的对象，该对象有一个AsyncWaitHandle属性是用来等待异步任务执行结束的一个同步信号。如果等待AsyncWaitHandle则，异步会阻塞并转为同步执行。 // 同步阻塞方式 using(var fs = File.OpenRead(\"/Users/zhangcheng/test.txt\")) { var buffer = new byte[10*1024]; var aResult = fs.BeginRead(buffer, 0, buffer.Length, null, null); aResult.AsyncWaitHandle.WaitOne(); //同步等待任务执行结束 fs.EndRead(aResult); Console.WriteLine(Encoding.UTF8.GetString(buffer)); } 2.3 委托异步调用 旧版.NET中,委托类型具有Invoke和BeginInvoke两个方法分别用于同步和异步调用委托。其中BeginInvoke使用的就是APL风格。 通过BeginInvoke异步调用委托在.NET Core中不被支持。 var addDel = new Func((a, b) => { Thread.Sleep(500); //模拟耗时操作 return (a + b).ToString(); }); //委托同步调用 var res = addDel.Invoke(1, 2); res = addDel(1, 2); //简化写法 //委托异步调用 addDel.BeginInvoke(1, 2, ar => { var result = addDel.EndInvoke(ar); Console.WriteLine(result); }, addDel); 3. TPL 3.1 简单使用 TPL是Task Parallel Library(并行任务库存)是.Net 4.0 之后带来的新特性,更简洁,更方便。现在.Net 平台下已经广泛使用。 static async Task Test() { using (var fs = File.OpenRead(\"/Users/zhangcheng/test.txt\")) { var buffer = new byte[10 * 1024]; await fs.ReadAsync(buffer, 0, buffer.Length); Console.WriteLine(Encoding.UTF8.GetString(buffer)); } } TPL风格运行我们用线性方式编写异步程序。 .NET中目前大多数耗时操作都提供了TPL风格的方法。 TPL风格编程可以大幅提升系统吞吐量，B/S程序效果更为显著，可以使用异步编程的地方尽量不要使用同步。 await会确保异步结果返回后再执行后续代码，不会阻塞主线程。 TPL风格方法都习惯以 Async结尾。 使用await关键字方法必须使用async修饰 接口中声明方法时不能使用async关键字，在其实现类中可以。 TPL风格方法允许以下三种类型的返回值： Task。异步Task做返回类型，相当于无返回值。方法被调用时支持await等待。 Task。T为异步方法内部实际返回类型。 void。使用void做返回类型的异步方法，被调用时不支持await等待。 3.2 同步调用 返回Task或TaskTPL方法可以同步调用。调用Task对象的Wait()方法会同步阻塞线程直到任务执行完成，然后可以通过其Result属性拿到最终执行结果。 在同步方法中不使用await而直接使用Task对象的Result属性也会导致等待阻塞。 Task task = TestAsync(); task.Wait(); //同步等待 Console.Writeline(task.Result); //拿到执行结果 使用APL风格\b编程，一定要全程使用异步，中间任何环节使用同步，不仅不会提升程序性能，而且容易造成死锁。 3.3 并行异步 如果存在多个相互无关联的异步任务，使用await语法会让多个任务顺序执行，如果想实现并发执行，我们可以使用Task.WhenAll()方式。 static async Task GetWeatherAsync() { using (var hc = new HttpClient()) { //三个顺序执行 Console.WriteLine(await hc.GetStringAsync(\"https://baidu.com/getweather\")); Console.WriteLine(await hc.GetStringAsync(\"https://google.com/getweather\")); Console.WriteLine(await hc.GetStringAsync(\"https://bing.com/getweather\")); } } 使用Task.WhenAll()改造后如下： static async Task GetWeatherAsync() { using (var hc = new HttpClient()) { var task1 = hc.GetStringAsync(\"https://baidu.com/getweather\"); var task2 = hc.GetStringAsync(\"https://google.com/getweather\"); var task3 = hc.GetStringAsync(\"https://bing.com/getweather\"); // 三个任务并行执行 var results = await Task.WhenAll(task1, task2, task3); foreach (var result in results) Console.WriteLine(result); } } 3.4 自定义异步方法 Task DoAsync() { return Task.Run(() => { // do something }); } Task DoAsync() { return Task.Run(() => { //do something return \"Hello\"; }); } Task GetDate() { // 从简单对象Task 可以使用 Task.FromResult() return Task.FromResult(DateTime.Today); } 3.5 异常处理 TPL风格编程中,有些情况下程序出现异常而不会抛出，也不会导致程序异常退出，此时会导致一些莫名的错误。但是显式的使用try...catch可以捕获到这些异常，这就要求开发者在代码编写过程中谨慎权衡，在可能出现的异常的地方进行手动异常处理。 TPL编程有时会抛出AggregateException,这通常发生在并行有多个任务执行的情况下,如上面并行异步案例的情况。多个并行任务可能有多个异常, 因此AggregateException是一个聚合型异常类型，通过其InnerExceptions 属性可以获得多个异常对象信息，逐个解析即可。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/unittest.html":{"url":"pages/unittest.html","title":"2. 单元测试","keywords":"","body":"单元测试 单元测试 1. 单元测试简介 1.1 单元测试作用 1.2 单元测试必要性 1.3 TDD 1.4 单元测试的正确姿势 2. .NET单元测试 2.1 Attributes 2.2 Assertions 2.3 Xunit示例 1. 单元测试简介 单元测试是针对程序的最小单元来进行正确性检验的测试工作，程序单元就是应用的最小可测试部件，一个单元可能是单个程序，类，对象，方法等。单元测试的想法是写一个方法之前就想好这个方法有什么样的输入输出,在开发完成就 测试一下给定的输出是不是产生期望的输出。 1.1 单元测试作用 减少bug 单元测试的目的就是通过足够准确的测试用例保证代码逻辑是正确。所以，在单测过程中，必然可以解决一些bug。因为，一旦某条测试用例没有通过，那么我们就会修改被测试的代码来保证能够通过测试。 减少修复bug的成本 一般解决bug的思路都是先通过各种手段定位问题，然后在解决问题。定位问题的时候如果没有单元测试，就只能通过debug的方式一点一点的追踪代码。解决问题的时候更是需要想尽各种方法来重现问题，然后改代码，改了代码之后在集成测试。 因为单元规模较小，复杂性较低，因而发现错误后容易隔离和定位，有利于调试工作。 帮助重构，提高重构的成功率 我相信，对一个程序员来说最痛苦的事就是修改别人的代码。有时候，一个很大的系统会导致很多人不敢改，因为他不知道改了一个地方会不会导致其他地方出错。可以，一旦有了单元测试，开发人员可以很方便的重构代码，只要在重构之后跑一遍单元测试就可以知道是不是把代码“改坏了” 提高开发速度 不写单测也许能让开发速度更快，但是无法保证自己写出来的代码真的可以正确的执行。写单测可以较少很多后期解决bug的时间。也能让我们放心的使用自己写出来的代码。整体提高开发速度。 1.2 单元测试必要性 单元测试可以在软件开发过程的早期就能发现问题。从表面上看，为每个单元程序都编写测试代码似乎是增加了工作量，但是其实这些代码不仅为你织起了一张保护网，而且还可以帮助你快速定位错误从而使你大大减少修复BUG的时间。只要单测的测试用例足够好，那么就可以避免很多低级错误。好的单测不仅不会浪费时间，还会大大节省我们的时间。 其实单元测试不仅能保证项目进度还能优化你的设计。设计的程序耦合度也越来越低。每个单元程序的输入输出，业务内容和异常情况都会尽可能变得简单。 1.3 TDD Test-Driven Development, 测试驱动开发， 是敏捷开发的一项核心实践和技术，也是一种设计方法论。TDD原理是开发功能代码之前，先编写测试用例代码，然后针对测试用例编写功能代码，使其能够通过。由于TDD对开发人员要求非常高，跟传统开发思维不一样，因此实施起来相当困难。 测试驱动开发有好处也有坏处。因为每个测试用例都是根据需求来的，或者说把一个大需求分解成若干小需求编写测试用例，所以测试用例写出来后，开发者写的执行代码，必须满足测试用例。如果测试不通过，则修改执行代码，直到测试用例通过。 1.4 单元测试的正确姿势 越重要的代码，越要写单元测试； 代码做不到单元测试，多思考如何改进，而不是放弃； 边写业务代码，边写单元测试，而不是完成整个新功能后再写； 多思考如何改进、简化测试代码。 2. .NET单元测试 .NET中常见的测试框架有MSTest、Nunit和Xunit,目前比较流行的是Xunit。作为NUnit的改进版，xUnit.Net确实克服了NUnit的不少缺点。xUnit.Net的Assert更精简但是又足以满足单元测试的需要，相比之下NUnit的Assert API略显臃肿。 2.1 Attributes NUnit 3.x MSTest 15.x xUnit.net 2.x Comments [Test] [TestMethod] [Fact] Marks a test method. [TestFixture] [TestClass] n/a xUnit.net does not require an attribute for a test class; it looks for all test methods in all public (exported) classes in the assembly. [ExpectedException] [ExpectedException] Assert.ThrowsRecord.Exception xUnit.net has done away with the ExpectedException attribute in favor of Assert.Throws. [SetUp] [TestInitialize] Constructor We believe that use of [SetUp] is generally bad. However, you can implement a parameterless constructor as a direct replacement. [TearDown] [TestCleanup] IDisposable.Dispose We believe that use of [TearDown] is generally bad. However, you can implement IDisposable.Dispose as a direct replacement. [OneTimeSetUp] [ClassInitialize] IClassFixture To get per-class fixture setup, implement IClassFixture on your test class. [OneTimeTearDown] [ClassCleanup] IClassFixture To get per-class fixture teardown, implement IClassFixture on your test class. n/a n/a ICollectionFixture To get per-collection fixture setup and teardown, implement ICollectionFixture on your test collection. [Ignore(\"reason\")] [Ignore] [Fact(Skip=\"reason\")] Set the Skip parameter on the [Fact] attribute to temporarily skip a test. [Property] [TestProperty] [Trait] Set arbitrary metadata on a test n/a [DataSource] [Theory],[XxxData] Theory (data-driven test). 2.2 Assertions NUnit 3.x (Constraint) MSTest 15.x xUnit.net 2.x Comments Is.EqualTo AreEqual Equal MSTest and xUnit.net support generic versions of this method Is.Not.EqualTo AreNotEqual NotEqual MSTest and xUnit.net support generic versions of this method Is.Not.SameAs AreNotSame NotSame Is.SameAs AreSame Same Does.Contain Contains Contains Does.Not.Contain DoesNotContain DoesNotContain Throws.Nothing n/a n/a Ensures that the code does not throw any exceptions. See Note 5 n/a Fail n/a xUnit.net alternative: Assert.True(false, \"message\") Is.GreaterThan n/a n/a xUnit.net alternative: Assert.True(x > y) Is.InRange n/a InRange Ensures that a value is in a given inclusive range Is.AssignableFrom n/a IsAssignableFrom Is.Empty n/a Empty Is.False IsFalse FALSE Is.InstanceOf IsInstanceOfType IsType Is.NaN n/a n/a xUnit.net alternative: Assert.True(double.IsNaN(x)) Is.Not.AssignableFrom n/a n/a xUnit.net alternative: Assert.False(obj is Type) Is.Not.Empty n/a NotEmpty Is.Not.InstanceOf IsNotInstanceOfType IsNotType Is.Not.Null IsNotNull NotNull Is.Null IsNull Null Is.True IsTrue TRUE Is.LessThan n/a n/a xUnit.net alternative: Assert.True(x Is.Not.InRange n/a NotInRange Ensures that a value is not in a given inclusive range Throws.TypeOf n/a Throws Ensures that the code throws an exact exception 2.3 Xunit示例 xUnit基本使用参见https://xunit.github.io/docs/getting-started/netfx/visual-studio public class TemplateTest : IClassFixture { private readonly TempateFixture _fixture; //相当于[TestInitialize] public TemplateTest(TempateFixture fixture) { _fixture = fixture; } [Fact] public void Test1() { Assert.Equal(\"Colin\",_fixture.Name); } [Fact] public void Test2() { Assert.True(true); } } public class TempateFixture : IDisposable { public string Name { get; set; } //相当于[ClassInitialize] public TempateFixture() { //数据初始化 Name = \"Colin\"; } //相当于[ClassCleanup] public void Dispose() { //数据清理 Name = null; } } TempateFixture中构造函数和Dispose在单个或多个测试用例都只会执行一次。TemplateTest中构造函数和Dispose(如果直接实现IDisposable)则会在每个测试方法都执行一次。 单元测试应该符合可以重复执行的原则，所以我们通常会在测试结束后对测试产生的变化或恢复和清理，如删除产生的过程数据等。测试贡献和清理数据参见https://xunit.github.io/docs/shared-context 如果需要在单元测试中输出内容需要使用ITestOutputHelper对象，直接注入即可。 public class TemplateTest { private readonly ITestOutputHelper _testOutputHelper; public TemplateTest(ITestOutputHelper testOutputHelper) { _testOutputHelper = testOutputHelper; } [Fact] public void SaveAsTest() { _testOutputHelper.WriteLine(\"测试输出...\"); } } 实际案例可以参考 https://github.com/colin-chang/MongoHelper/blob/master/ColinChang.MongoHelper.Test/MongoHelperTest.cs © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-18 23:55:14 "},"pages/autofac.html":{"url":"pages/autofac.html","title":"1. AutoFac","keywords":"","body":"AutoFac © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/automapper.html":{"url":"pages/automapper.html","title":"2. AutoMapper","keywords":"","body":"AutoMappper 1. 简介 2. 基础应用 2.1 简单映射 2.2 扁平化映射 2.3 忽略成员 2.4 自定义映射 2.5 自定义多层映射 3. 高级应用 3.1 自定义值解析 3.2 动态类型映射 3.3 其他 1. 简介 Automapper 是一个简单而强大的工具库帮助我们处理对象之间的映射。这些工作通常是枯燥乏味的。目前该项目已被.NET基金会所支持。 问AutoMapper有多强大，一句话总结，AutoMapper可以处理几乎所有对象间映射的复杂场景。 2. 基础应用 AutoMapper 支持: .NET 4.6.1+ .NET Standard 2.0+ 通过Nuget获取AutoMappper即可使用。 2.1 简单映射 public class User { public int Id { get; set; } public int Age { get; set; } public string Name { get; set; } } public class UserDTO { public int Id { get; set; } public int Age { get; set; } public string Name { get; set; } } void BasicMap() { //初始化映射关系 Mapper.Initialize(cfg => cfg.CreateMap()); var user = new User {Id = 1, Age = 18, Name = \"Colin\"}; var userDto = Mapper.Map(user);//对象映射 } AutoMapper中存在以下常用特性： AutoMapper将自动忽略空引用异常 对象成员映射不区分大小写 继承对象支持映射。 2.2 扁平化映射 遵守AutoMapper映射约定命名规范，可以实现对象扁平化映射。目标类属性必须是 源类型中 复杂属性名称+复杂属性类型的内部属性名称。AutoMapper会深度搜索目标类，直到找到匹配的属性为止。 public class Employee { public string Name { get; set; } public Company Company { get; set; } } public class Company { public string Name { get; set; } public string Address { get; set; } } public class EmployeeDto { public string Name { get; set; } public string CompanyName { get; set; } public string CompanyAddress { get; set; } } void FlatMap() { Mapper.Initialize(cfg => cfg.CreateMap()); var employee = new Employee { Name = \"Colin\", Company = new Company { Name = \"Chanyi\", Address = \"Beijing\" } }; var employeeDto = Mapper.Map(employee); } 2.3 忽略成员 对象映射过程中有些属性可能用不到，我们通过Ignore方法指定忽略映射属性，以减少映射开支和传输流量。 Mapper.Initialize(cfg => cfg.CreateMap() .ForMember(d => d.Age, o => o.Ignore()));//忽略Age属性映射 var user = new User {Id = 1, Age = 18, Name = \"Colin\"}; var userDto = Mapper.Map(user); 2.4 自定义映射 当源对象和目标对象的存在不同名或不同级的对应关系时，就需要在初始化映射时手动配置自定义映射关系。 public class Article { public int Id { get; set; } public string Content { get; set; } public string TypeName { get; set; } public IEnumerable Messages { get; set; } } public class ArticleDto { public int Id { get; set; } public string Content { get; set; } public string Category { get; set; } public IEnumerable Comments { get; set; } } void CustomMap() { Mapper.Initialize(cfg => cfg.CreateMap() .ForMember(d => d.Category, o => o.MapFrom(s => s.TypeName)) .ForMember(d => d.Comments, o => o.MapFrom(s => s.Messages)) ); var article = new Article {Id = 0, Content = \"content\", TypeName = \"fiction\", Messages = new[] {\"Good\"}}; var articleDto = Mapper.Map(article); } 2.5 自定义多层映射 自定义复杂对象映射中集合子元素或成员复杂类型又需要自定义映射关系时，姑且称为自定义多层映射，此时我们就需要手动逐个配置映射关系。 public class Customer { public int Id { get; set; } public string Name { get; set; } public IEnumerable Orders { get; set; } } public class Order { public int Id { get; set; } public string TradeNo { get; set; } public int TotalFee { get; set; } } public class CustomerDto { public int Id { get; set; } public string Name { get; set; } public IEnumerable OrderDtos { get; set; } } public class OrderDto { public int Id { get; set; } public string TradeNo { get; set; } public int TotalFee { get; set; } } void MultilayerMap() { Mapper.Initialize(cfg => { //多层映射配置 cfg.CreateMap(); cfg.CreateMap() .ForMember(d => d.OrderDtos, o => o.MapFrom(s => s.Orders));//子成员属性映射 }); var customer = new Customer() { Id = 0, Name = \"Colin\", Orders = new List { new Order() { Id = 0, TotalFee = 10, TradeNo = \"123456\" } } }; var customerDto = Mapper.Map(customer); } 3. 高级应用 3.1 自定义值解析 AutoMapper支持自定义解析，需要提供IValueResolver对象。 public class Student { public string Name { get; set; } public int Score { get; set; } } public class StudentDto { public string Name { get; set; } public Grade Score { get; set; } } public enum Grade { A, B, C } //自定义解析器 public class ScoreResolver : IValueResolver { public Grade Resolve(Student source, StudentDto destination, Grade destMember, ResolutionContext context) { var score = source.Score; if (score >= 90) return Grade.A; else if (score >= 80) return Grade.B; else return Grade.C; } } void ValueResolverMap() { Mapper.Initialize(cfg => cfg.CreateMap().ForMember(d => d.Score, o => o.MapFrom())); var student = new Student {Name = \"Colin\", Score = 95}; var studentDto = Mapper.Map(student); } 3.2 动态类型映射 AutoMapper支持.Net动态对象映射。 private static void DynamicMap() { Mapper.Initialize(cfg => { });//动态类型映射不需要初始化配置内容 dynamic user = new ExpandoObject(); user.Id = 1; user.Name = \"Colin\"; user.Age = 18; var u = Mapper.Map(user); } 3.3 其他 AutoMapper支持依赖注入，支持ORM等。如对EF的支持示例如下： IQueryable customers = null; var customersDTO = customers.ProjectTo(); 结束语： 以上只是简单列举了AutoMapper的常用情景，其功能远不止如此，AutoMapper功能异常强大，几乎覆盖了对象映射的所有场景。更多更详尽的AutoMapper使用可以查阅其官方文档。 本文档中所有示例代码已共享到Github。 代码下载地址：https://github.com/colin-chang/AutoMapperSample 参考文档 https://yq.aliyun.com/articles/318075/ https://automapper.readthedocs.io/en/latest/ © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/https.html":{"url":"pages/https.html","title":"3. HTTPS","keywords":"","body":"全面 HTTPS 时代 1. HTTPS 简介 2. HTTPS 工作原理 3. HTTPS 现状分析 4. 免费升级到 HTTPS 5. GitHub Pages 自定义域名支持 HTTPS 1. HTTPS 简介 1) HTTP 的问题 认证网站 假如你正在访问支付宝，怎样确定你正在访问的是阿里巴巴提供的支付宝而不是假冒伪劣的钓鱼网站呢？ 数据安全 HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决上面的问题，HTTPS出场了 👏👏👏 2) HTTPS 是什么 传输层安全性（TLS）是HTTPS的官方名称，你可能听说过它称为SSL（安全套接字层），SSL是已弃用的名称，TLS是一种加密协议，可通过计算机网络提供安全通信。 HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL或TLS，HTTPS的安全基础是SSL/TLS。 HTTPS协议的主要作用有两个：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是认证网站的真实性。 2. HTTPS 工作原理 1) 主体对象 客户端。通常是浏览器(Chrome、IE、FireFox等)，也可以自己编写的各种语言的客户端程序。 服务端。一般指支持Https的网站，比如github、支付宝。 CA(Certificate Authorities)机构。Https证书签发和管理机构，比如Symantec、Comodo、GoDaddy、GlobalSign。 2) 工作流程 客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。 工作流程，基本分为三个阶段: 认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。 协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。 加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。 Https就是Http跑在SSL或者TLS上，所以本文讨论的原理和流程其实是SSL和TLS的流程，对于其它使用SSL或者TLS的应用层协议，本文内容一样有效。 3. HTTPS 现状分析 1) 优缺点分析 搞明白了Https的工作原理后，其优缺点就很容易理解了。 优点 尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，并且解决了网站认证的问题，这两点也正是我们在最开始提出的问题。另外，Google曾表示“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”，因此采用HTTPS的网站更有利于SEO. 缺点 HTTPS协议握手阶段比较费时，没有HTTP高效，且会使页面的加载时间延长近功耗增加； SSL证书收费 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名。 2) 现状分析 了解了HTTPS的优缺点，我们再来看下其发展现状。 一般来说，很多公司都会直接购买由GlobalSign、GeoTrust、Verisign等全球公认的数字证书颁发机构颁发的SSL证书。购买？没错，大多数SSL证书都需要按年付费使用，而且价格不菲。过去HTTPS被认为比较低效。这也是前面提到的HTTPS的主要缺点。 但随着技术的发展，现在机器变得更快，已经解决了性能问题，Let's Encrypt等机构提供免费TLS证书，这两项发展改变了游戏，并使TLS成为主流。 3) 免费证书 Let's Encrypt 是一个免费、开放，自动化的证书颁发机构，由 ISRG（Internet Security Research Group）运作。ISRG 是一个关注网络安全的公益组织，其赞助商包括 Mozilla、Akamai、Cisco、EFF、Chrome、IdenTrust、Facebook等公司。ISRG 的目的是消除资金和技术领域的障碍，全面推进网站从HTTP到HTTPS过度的进程。 目前，包括FireFox、Chrome在内的主流浏览器都支持Let's Encrypt证书，已经有不少用户在真实项目中使用Let's Encrypt证书。Let's Encrypt免费SSL证书的有效期是90天，到期后可以再续期，这样也就可以变相长期使用了。 4. 免费升级到 HTTPS 一般的HTTPS使用流程如下。 Let’s Encrypt TLS 免费证书使用 Let’s Encrypt TLS证书可以自动化生成和更新，由于他们是免费的，所以没有理由不去做。相信大家也更关注免费证书如何使用，不多说，这就搞起来 😊😊😊 以下案例使用 Ubuntu 18.10/nginx 1.15.5 环境。 根据Let’s Encrypt 官网推荐，我们选择使用 Certbot ACME client 选择对应的软件和操作系统环境 参照网站给出的命令进行安装/配置/更新 证书 完成以上配置后，访问你的网站，不出意外已经升级到https了👍 自动配置完成之后的Nginx的配置文件形如： server { server_name localhost 104.199.230.207 bet518.win www.bet518.win; location / { proxy_pass localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/bet518.win/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/bet518.win/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { if ($host = www.bet518.win) { return 301 https://$host$request_uri; } # managed by Certbot if ($host = bet518.win) { return 301 https://$host$request_uri; } # managed by Certbot listen 80; server_name localhost 104.199.230.207 bet518.win www.bet518.win; return 404; # managed by Certbot } 5. GitHub Pages 自定义域名支持 HTTPS 2018年5月1日，GitHub Pages 官方宣布 GitHub Pages 对自定义域名支持 HTTPS。 https://blog.github.com/2018-05-01-github-pages-custom-domains-https/ 什么，你问我为什么要GitHub Page使用HTTPS？简单来说，除了 HTTPS 自身带来的加密、防劫持等特性外，Github 官方基于 HTTPS 配合 CND，使得网站的加载速度更快，还能提供额外的防御 DDoS 攻击的保护。 GitHub官方文档已经说明了如何开启HTTPS。英文不熟悉的小伙伴看我下面的简单粗暴的讲解即可。 1）绑定域名 注册域名不多说。如何使用GitHub Pages中创建博客也不多说。废话完了，下面开始正题，以博主自己的账户为例(GitHub用户名为colin-chang) 解析域名 Github Pages 项目配置 打开 username.github.io 项目设置,并找到 GitHub Pages 模块的Custom domain填写自己的域名并点击 Save 在项目根目录新建一个名为 “CNAME” 的文件，内容为自己的域名 2）开启HTTPS 找到如下图所示的Enforce HTTPS选项并勾选。然后访问下自己的域名，不出意外的话，已经是https了。 那么如果如果之前已经开启了自定义域名， enforce HTTPS 无法勾选且怎么办？往下看... 把 Custom domain 中的值清空，并点击 Save 进行保存； 在 Custom domain 中的填入之前清空的值，填入后点击保存； 刷新项目设置页，如果 enforce HTTPS 可勾选，勾选即可； 如果 enforce HTTPS 不可勾选，并且提示 Not yet available for your site because the certificate has not finished being issued” ，说明证书尚未申请完成，等待一天即可。 完成以上步骤重新访问自己的域名，享受https吧开始 注意，如果使用仍然存在问题，请检查自己的网站引用的资源文件有没有使用了 http 协议，请替换成相应的 https 资源。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/mailsms.html":{"url":"pages/mailsms.html","title":"4. 邮件短信通知","keywords":"","body":"邮件和短信通知 1. 邮件通知 2. 短信通知 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "},"pages/staticssi.html":{"url":"pages/staticssi.html","title":"6. 页面静态化和SSI","keywords":"","body":"页面静态化和SSI 1. 页面静态化 即使使用缓存,只是降低数据库服务器压力,web 服务器仍然是“每次来访都要跑 一遍代码”,如果所有人访问的结果都一样,就可以直接要响应的内容保存成 html 文件,让用户访问 html 文件。 缓存和静态页的区别:静态页的性能比缓存好,能用静态页就用静态页。什么情况下不能用静态页:相同的地址不同的人看的不一样、有的页面有的人不能看。 1.1 MVC 之前都是用户请求 Action,获取 html 响应去显示,那么怎么样通过程序去请求 Action 获取响应呢? 首先定义如下的方法: static string RenderViewToString(ControllerContext context, string viewPath, object model = null) { var viewEngineResult = ViewEngines.Engines.FindView(context, viewPath, null); if (viewEngineResult == null) throw new FileNotFoundException(\"View\" + viewPath + \"cannot be found.\"); var view = viewEngineResult.View; context.Controller.ViewData.Model = model; using (var sw = new StringWriter()) { var ctx = new ViewContext(context, view, context.Controller.ViewData, context.Controller.TempData, sw); view.Render(ctx, sw); return sw.ToString(); } } 然后如下调用: ```csharp string html = RenderViewToString(this.ControllerContext, \"~/Views/Home/Index.cshtml\", person); File.WriteAllText(\"home_index.html\",html); 静态化之后可以将用户对/Home/Index的请求转为/home_index.html。既可以在生成客户端链接的时候直接使用静态地址，也可以在服务端通过路由重定项等处理。 我们通常只对读多写少的内容进行页面静态化处理，当静态化的页面内容发生“增删改”操作时，重新生成对应的静态页面即可。 1.2 WebAPI 目前Web开发中前后端分离技术逐渐成为趋势。前后端分离之后项目架构可以简单抽象为UI + WebAPI。那么如何在前后端分离架构中进行页面静态化呢。 页面静态化本质是在HTML组装完成之后将其保存为静态文件，用户请求时直接返回保存的静态文件而不用再次动态组装。那在前后端分离之后，HTML的组装工作都是在UI完成，所以直接在UI层编写静态化逻辑即可。新增需要静态化的资源时，请求API数据组装HTML并使用JS将组装完成的HTML页面另存下来，其内容发生增删改操作时再次请求API重新组装即可。 2. SSI https://www.jianshu.com/p/3898780ac1c9 https://www.cnblogs.com/dehigher/p/10127380.html © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2020-07-09 15:30:26 "}}